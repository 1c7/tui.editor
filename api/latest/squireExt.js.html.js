tui.util.defineNamespace("fedoc.content", {});
fedoc.content["squireExt.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview Implements\n * @author Sungho Kim(sungho-kim@nhnent.com) FE Development Team/NHN Ent.\n */\n\n'use strict';\n\nvar domUtils = require('./domUtils');\n\nvar Squire = window.Squire,\n    util = tui.util;\n\nvar FIND_BLOCK_TAGNAME_RX = /\\b(H[\\d]|LI|P|BLOCKQUOTE|TD)\\b/;\n\nvar isIElt11 = /Trident\\/[456]\\./.test(navigator.userAgent);\n\n/**\n * SquireExt\n * @exports SquireExt\n * @augments Squire\n * @constructor\n * @class\n */\nfunction SquireExt() {\n    Squire.apply(this, arguments);\n\n    this._decorateHandlerToCancelable('copy');\n    this._decorateHandlerToCancelable(isIElt11 ? 'beforepaste' : 'paste');\n}\n\nSquireExt.prototype = util.extend(\n    {},\n    Squire.prototype\n);\n\nSquireExt.prototype.get$Body = function() {\n    this.$body = this.$body || $(this.getRoot());\n\n    return this.$body;\n};\n\n/**\n * _decorateHandlerToCancelable\n * Decorate squire handler to cancelable cuz sometimes, we dont need squire handler process\n * @param {string} eventName event name\n */\nSquireExt.prototype._decorateHandlerToCancelable = function(eventName) {\n    var handlers, handler;\n\n    handlers = this._events[eventName];\n\n    if (handlers.length > 1) {\n        throw new Error('too many' + eventName + ' handlers in squire');\n    }\n\n    handler = handlers[0].bind(this);\n\n    handlers[0] = function decoratedSquireHandler(event) {\n        if (!event.defaultPrevented) {\n            handler(event);\n        }\n    };\n};\n\nSquireExt.prototype.changeBlockFormat = function(srcCondition, targetTagName) {\n    var self = this;\n\n    this.modifyBlocks(function(frag) {\n        var current, newFrag, newBlock, nextBlock, tagName, lastNodeOfNextBlock, appendChidToNextBlock;\n\n        //HR은 Block으로 치지 않아서 frag에나타나지 않는다\n        //디폴트 블럭을 만들어준다.\n        if (frag.childNodes.length) {\n            current = frag.childNodes[0];\n        } else {\n            current = self.createDefaultBlock();\n            frag.appendChild(current);\n        }\n\n        if (srcCondition) {\n            //find last depth\n            while (current.firstChild) {\n                current = current.firstChild;\n            }\n\n            appendChidToNextBlock = function(node) {\n                nextBlock.appendChild(node);\n            };\n\n            //find tag\n            while (current !== frag) {\n                tagName = current.tagName;\n\n                if (util.isFunction(srcCondition) ? srcCondition(tagName) : (tagName === srcCondition)) {\n                    nextBlock = current.childNodes[0];\n\n                    //there is no next blocktag\n                    //eslint-disable-next-line max-depth\n                    if (!domUtils.isElemNode(nextBlock) || current.childNodes.length > 1) {\n                        nextBlock = self.createDefaultBlock();\n\n                        util.forEachArray(util.toArray(current.childNodes), appendChidToNextBlock);\n\n                        lastNodeOfNextBlock = nextBlock.lastChild;\n\n                        //remove unneccesary br\n                        //eslint-disable-next-line max-depth\n                        if (lastNodeOfNextBlock &amp;&amp; domUtils.getNodeName(lastNodeOfNextBlock) === 'BR') {\n                            nextBlock.removeChild(lastNodeOfNextBlock);\n                        }\n                    }\n\n                    //eslint-disable-next-line max-depth\n                    if (targetTagName) {\n                        newBlock = self.createElement(targetTagName, [nextBlock]);\n                    } else {\n                        newBlock = nextBlock;\n                    }\n\n                    newFrag = self.getDocument().createDocumentFragment();\n                    newFrag.appendChild(newBlock);\n\n                    frag = newFrag;\n\n                    break;\n                }\n\n                current = current.parentNode;\n            }\n        }\n\n        //if source condition node is not founded, we wrap current div node with node named targetTagName\n        if (\n            (!newFrag || !srcCondition)\n            &amp;&amp; targetTagName\n            &amp;&amp; domUtils.getNodeName(frag.childNodes[0]) === 'DIV'\n        ) {\n            frag = self.createElement(targetTagName, [frag.childNodes[0]]);\n        }\n\n        return frag;\n    });\n};\n\nSquireExt.prototype.changeBlockFormatTo = function(targetTagName) {\n    this.changeBlockFormat(function(tagName) {\n        return FIND_BLOCK_TAGNAME_RX.test(tagName);\n    }, targetTagName);\n};\n\nSquireExt.prototype.getCaretPosition = function() {\n    return this.getCursorPosition();\n};\n\nSquireExt.prototype.replaceSelection = function(content, selection) {\n    if (selection) {\n        this.setSelection(selection);\n    }\n\n    this._ignoreChange = true;\n    this.insertHTML(content);\n};\n\nSquireExt.prototype.replaceRelativeOffset = function(content, offset, overwriteLength) {\n    var selection;\n\n    selection = this.getSelection().cloneRange();\n\n    this._replaceRelativeOffsetOfSelection(content, offset, overwriteLength, selection);\n};\n\nSquireExt.prototype._replaceRelativeOffsetOfSelection = function(content, offset, overwriteLength, selection) {\n    var startSelectionInfo, endSelectionInfo, finalOffset;\n    var endOffsetNode = selection.endContainer;\n    var endTextOffset = selection.endOffset;\n\n    if (domUtils.getNodeName(endOffsetNode) !== 'TEXT') {\n        endOffsetNode = this._getClosestTextNode(endOffsetNode, endTextOffset);\n\n        if (endOffsetNode) {\n            if (domUtils.isTextNode(endOffsetNode)) {\n                endTextOffset = endOffsetNode.nodeValue.length;\n            } else {\n                endTextOffset = endOffsetNode.textContent.length;\n            }\n        }\n    }\n\n    if (endOffsetNode) {\n        startSelectionInfo = this.getSelectionInfoByOffset(endOffsetNode, endTextOffset + offset);\n        selection.setStart(startSelectionInfo.element, startSelectionInfo.offset);\n\n        finalOffset = endTextOffset + (offset + overwriteLength);\n        endSelectionInfo = this.getSelectionInfoByOffset(endOffsetNode, finalOffset);\n        selection.setEnd(endSelectionInfo.element, endSelectionInfo.offset);\n\n        this.replaceSelection(content, selection);\n    } else {\n        this.replaceSelection(content);\n    }\n};\n\nSquireExt.prototype._getClosestTextNode = function(node, offset) {\n    var foundNode = domUtils.getChildNodeByOffset(node, offset - 1);\n\n    if (domUtils.getNodeName(foundNode) !== 'TEXT') {\n        foundNode = foundNode.previousSibling;\n    }\n\n    return foundNode;\n};\n\nSquireExt.prototype.getSelectionInfoByOffset = function(anchorElement, offset) {\n    var traceElement, traceElementLength, traceOffset, stepLength;\n    var direction = offset >= 0 ? 'next' : 'previous';\n    var offsetAbs = Math.abs(offset);\n    var latestAvailableElement = traceElement;\n\n    if (direction === 'next') {\n        traceElement = anchorElement;\n    } else {\n        traceElement = anchorElement.previousSibling;\n    }\n\n    traceOffset = offsetAbs;\n    stepLength = 0;\n\n    while (traceElement) {\n        if (domUtils.isTextNode(traceElement)) {\n            traceElementLength = traceElement.nodeValue.length;\n        } else {\n            traceElementLength = traceElement.textContent.length;\n        }\n\n        stepLength += traceElementLength;\n\n        if (offsetAbs &lt;= stepLength) {\n            break;\n        }\n\n        traceOffset -= traceElementLength;\n\n        if (domUtils.getTextLength(traceElement) > 0) {\n            latestAvailableElement = traceElement;\n        }\n\n        traceElement = traceElement[direction + 'Sibling'];\n    }\n\n    if (!traceElement) {\n        traceElement = latestAvailableElement;\n        traceOffset = domUtils.getTextLength(traceElement);\n    }\n\n    if (direction === 'previous') {\n        traceOffset = domUtils.getTextLength(traceElement) - traceOffset;\n    }\n\n    return {\n        element: traceElement,\n        offset: traceOffset\n    };\n};\n\nSquireExt.prototype.getSelectionPosition = function(selection, style, offset) {\n    var pos, range, endSelectionInfo,\n        marker = this.createElement('INPUT');\n\n    range = selection.cloneRange();\n\n    range.setStart(range.startContainer, range.startOffset);\n    endSelectionInfo = this.getSelectionInfoByOffset(selection.endContainer, selection.endOffset + (offset || 0));\n    range.setEnd(endSelectionInfo.element, endSelectionInfo.offset);\n\n    //to prevent squire input event fire\n    this._ignoreChange = true;\n    this.insertElement(marker, range);\n    pos = $(marker).offset();\n\n    if (style !== 'over') {\n        pos.top += $(marker).outerHeight();\n    }\n\n    marker.parentNode.removeChild(marker);\n\n    selection.setStart(selection.endContainer, selection.endOffset);\n    selection.collapse(true);\n\n    this.setSelection(selection);\n\n    return pos;\n};\n\nSquireExt.prototype.removeLastUndoStack = function() {\n    if (this._undoStack.length) {\n        this._undoStackLength -= 1;\n        this._undoIndex -= 1;\n        this._undoStack.pop();\n        this._isInUndoState = false;\n    }\n};\n\nSquireExt.prototype.replaceParent = function(node, from, to) {\n    var target;\n    target = $(node).closest(from);\n\n    if (target.length) {\n        target.wrapInner('&lt;' + to + '/>');\n        target.children().unwrap();\n    }\n};\n\nSquireExt.prototype.preserveLastLine = function() {\n    var lastBlock = this.get$Body().children().last();\n\n    if (domUtils.getNodeName(lastBlock[0]) !== 'DIV') {\n        this._ignoreChange = true;\n        $(this.createDefaultBlock()).insertAfter(lastBlock);\n    }\n};\n\nSquireExt.prototype.scrollTop = function(top) {\n    if (util.isUndefined(top)) {\n        return this.get$Body().scrollTop();\n    }\n\n    return this.get$Body().scrollTop(top);\n};\n\nSquireExt.prototype.isIgnoreChange = function() {\n    return this._ignoreChange;\n};\n\nmodule.exports = SquireExt;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"