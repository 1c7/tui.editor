tui.util.defineNamespace("fedoc.content", {});
fedoc.content["domUtils.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview\n * @author Sungho Kim(sungho-kim@nhnent.com) FE Development Team/NHN Ent.\n */\n\n'use strict';\n\nvar FIND_ZWB = /\\u200B/g;\n\nvar util = tui.util;\n\n/**\n * isTextNode\n * Check if node is text node\n * @param {Node} node node to check\n * @returns {boolean} result\n */\nvar isTextNode = function(node) {\n    return node &amp;&amp; node.nodeType === Node.TEXT_NODE;\n};\n\n/**\n * isElemNode\n * Check if node is element node\n * @param {Node} node node to check\n * @returns {boolean} result\n */\nvar isElemNode = function(node) {\n    return node &amp;&amp; node.nodeType === Node.ELEMENT_NODE;\n};\n\n/**\n * getNodeName\n * Get node name of node\n * @param {Node} node node\n * @returns {string} node name\n */\nvar getNodeName = function(node) {\n    if (isElemNode(node)) {\n        return node.tagName;\n    }\n\n    return 'TEXT';\n};\n\n/**\n * getTextLength\n * Get node offset length of node(for Range API)\n * @param {Node} node node\n * @returns {number} length\n */\nvar getTextLength = function(node) {\n    var len;\n\n    if (isElemNode(node)) {\n        len = node.textContent.replace(FIND_ZWB, '').length;\n    } else if (isTextNode(node)) {\n        len = node.nodeValue.replace(FIND_ZWB, '').length;\n    }\n\n    return len;\n};\n\n/**\n * getOffsetLength\n * Get node offset length of node(for Range API)\n * @param {Node} node node\n * @returns {number} length\n */\nvar getOffsetLength = function(node) {\n    var len;\n\n    if (isElemNode(node)) {\n        len = node.childNodes.length;\n    } else if (isTextNode(node)) {\n        len = node.nodeValue.replace(FIND_ZWB, '').length;\n    }\n\n    return len;\n};\n\n/**\n * getNodeOffsetOfParent\n * get node offset between parent's childnodes\n * @param {Node} node node\n * @returns {number} offset(index)\n */\nvar getNodeOffsetOfParent = function(node) {\n    var i, t, found,\n        childNodesOfParent = node.parentNode.childNodes;\n\n    for (i = 0, t = childNodesOfParent.length; i &lt; t; i += 1) {\n        if (childNodesOfParent[i] === node) {\n            found = i;\n            break;\n        }\n    }\n\n    return found;\n};\n\n/**\n * getChildNodeByOffset\n * get child node by offset\n * @param {Node} node node\n * @param {number} index offset index\n * @returns {Node} foudned node\n */\nvar getChildNodeByOffset = function(node, index) {\n    var currentNode;\n\n    if (isTextNode(node)) {\n        currentNode = node;\n    } else if (node.childNodes.length &amp;&amp; index >= 0) {\n        currentNode = node.childNodes[index];\n    }\n\n    return currentNode;\n};\n\n/**\n * getNodeWithDirectionUntil\n * find next node from passed node\n * 노드의 다음 노드를 찾는다 sibling노드가 없으면 부모레벨까지 올라가서 찾는다.\n * 부모노드를 따라 올라가며 방향에 맞는 노드를 찾는다.\n * @param {strong} direction previous or next\n * @param {Node} node node\n * @param {string} untilNodeName parent node name to limit\n * @returns {Node} founded node\n */\nvar getNodeWithDirectionUntil = function(direction, node, untilNodeName) {\n    var directionKey = direction + 'Sibling',\n        nodeName, foundedNode;\n\n\n    while (node &amp;&amp; !node[directionKey]) {\n        nodeName = getNodeName(node.parentNode);\n\n        if ((nodeName === untilNodeName)\n            || nodeName === 'BODY'\n        ) {\n            break;\n        }\n\n        node = node.parentNode;\n    }\n\n    if (node[directionKey]) {\n        foundedNode = node[directionKey];\n    }\n\n    return foundedNode;\n};\n\n/**\n * getPrevOffsetNodeUntil\n * get prev node of childnode pointed with index\n * 인덱스에 해당하는 차일드 노드의 이전 노드를 찾는다.\n * @param {Node} node node\n * @param {number} index offset index\n * @param {string} untilNodeName parent node name to limit\n * @returns {Node} founded node\n */\nvar getPrevOffsetNodeUntil = function(node, index, untilNodeName) {\n    var prevNode;\n\n    if (index > 0) {\n        prevNode = getChildNodeByOffset(node, index - 1);\n    } else {\n        prevNode = getNodeWithDirectionUntil('previous', node, untilNodeName);\n    }\n\n    return prevNode;\n};\n\nvar getParentUntilBy = function(node, condition) {\n    var foundedNode;\n\n    while (node.parentNode &amp;&amp; !condition(node.parentNode)) {\n        node = node.parentNode;\n    }\n\n    if (condition(node.parentNode)) {\n        foundedNode = node;\n    }\n\n    return foundedNode;\n};\n\n/**\n * getParentUntil\n * get parent node until paseed node name\n * 특정 노드이전의 부모 노드를 찾는다\n * @param {Node} node node\n * @param {string|HTMLNode} untilNode node name or node to limit\n * @returns {Node} founded node\n */\nvar getParentUntil = function(node, untilNode) {\n    var foundedNode;\n\n    if (util.isString(untilNode)) {\n        foundedNode = getParentUntilBy(node, function(targetNode) {\n            return untilNode === getNodeName(targetNode);\n        });\n    } else {\n        foundedNode = getParentUntilBy(node, function(targetNode) {\n            return untilNode === targetNode;\n        });\n    }\n\n    return foundedNode;\n};\n\n\n/**\n * getNodeWithDirectionUnderParent\n * get node of direction before passed parent\n * 주어진 노드 이전까지 찾아올라가서 방향에 맞는 노드를 찾는다.\n * @param {strong} direction previous or next\n * @param {Node} node node\n * @param {string|Node} underNode parent node name to limit\n * @returns {Node} founded node\n */\nvar getNodeWithDirectionUnderParent = function(direction, node, underNode) {\n    var directionKey = direction + 'Sibling',\n        foundedNode;\n\n    node = getParentUntil(node, underNode);\n\n    if (node &amp;&amp; node[directionKey]) {\n        foundedNode = node[directionKey];\n    }\n\n    return foundedNode;\n};\n\n/**\n * getTopPrevNodeUnder\n * get top previous top level node under given node\n * @param {Node} node node\n * @param {Node} underNode underNode\n * @returns {Node} founded node\n */\nvar getTopPrevNodeUnder = function(node, underNode) {\n    return getNodeWithDirectionUnderParent('previous', node, underNode);\n};\n\n/**\n * getNextTopBlockNode\n * get next top level block node\n * @param {Node} node node\n * @param {Node} underNode underNode\n * @returns {Node} founded node\n */\nvar getTopNextNodeUnder = function(node, underNode) {\n    return getNodeWithDirectionUnderParent('next', node, underNode);\n};\n\n/**\n * Get parent element the body element\n * @param {Node} node Node for start searching\n * @returns {Node}\n */\nvar getTopBlockNode = function(node) {\n    return getParentUntil(node, 'BODY');\n};\n\n/**\n * Get previous text node\n * @param {Node} node Node for start searching\n * @returns {Node}\n */\nvar getPrevTextNode = function(node) {\n    node = node.previousSibling || node.parentNode;\n\n    while (!isTextNode(node) &amp;&amp; getNodeName(node) !== 'BODY') {\n        if (node.previousSibling) {\n            node = node.previousSibling;\n\n            while (node.lastChild) {\n                node = node.lastChild;\n            }\n        } else {\n            node = node.parentNode;\n        }\n    }\n\n    if (getNodeName(node) === 'BODY') {\n        node = null;\n    }\n\n    return node;\n};\n\n/**\n * find node by offset\n * @param {HTMLElement} root Root element\n * @param {Array.&lt;number>} offsetList offset list\n * @param {function} textNodeFilter Text node filter\n * @returns {Array}\n */\nvar findOffsetNode = function(root, offsetList, textNodeFilter) {\n    var result = [],\n        text = '',\n        walkerOffset = 0,\n        offset, walker, newWalkerOffset;\n\n    if (!offsetList.length) {\n        return result;\n    }\n\n    offset = offsetList.shift();\n    walker = document.createTreeWalker(root, 4, null, false);\n\n    while (walker.nextNode()) {\n        text = walker.currentNode.nodeValue || '';\n\n        if (textNodeFilter) {\n            text = textNodeFilter(text);\n        }\n\n        newWalkerOffset = walkerOffset + text.length;\n\n        while (newWalkerOffset >= offset) {\n            result.push({\n                container: walker.currentNode,\n                offsetInContainer: offset - walkerOffset,\n                offset: offset\n            });\n\n            if (!offsetList.length) {\n                return result;\n            }\n            offset = offsetList.shift();\n        }\n        walkerOffset = newWalkerOffset;\n    }\n\n    //오프셋에 해당하는 컨텐츠가 없는경우 컨텐츠 맨마지막으로 통일\n    //중간에 return으로 빠져나가지 않고 여기까지 왔다는것은 남은 offset이 있는것임\n    do {\n        result.push({\n            container: walker.currentNode,\n            offsetInContainer: text.length,\n            offset: offset\n        });\n        offset = offsetList.shift();\n    } while (!util.isUndefined(offset));\n\n    return result;\n};\n\nvar getNodeInfo = function(node) {\n    var path = {};\n    var className;\n\n    path.tagName = node.nodeName;\n\n    if (node.id) {\n        path.id = node.id;\n    }\n\n    className = node.className.trim();\n\n    if (className) {\n        path.className = className;\n    }\n\n    return path;\n};\n\nvar getPath = function(node, root) {\n    var paths = [];\n\n    while (node &amp;&amp; node !== root) {\n        if (isElemNode(node)) {\n            paths.unshift(getNodeInfo(node));\n        }\n\n        node = node.parentNode;\n    }\n\n    return paths;\n};\n\nmodule.exports = {\n    getNodeName: getNodeName,\n    isTextNode: isTextNode,\n    isElemNode: isElemNode,\n    getTextLength: getTextLength,\n    getOffsetLength: getOffsetLength,\n    getPrevOffsetNodeUntil: getPrevOffsetNodeUntil,\n    getNodeOffsetOfParent: getNodeOffsetOfParent,\n    getChildNodeByOffset: getChildNodeByOffset,\n    getTopPrevNodeUnder: getTopPrevNodeUnder,\n    getTopNextNodeUnder: getTopNextNodeUnder,\n    getParentUntil: getParentUntil,\n    getTopBlockNode: getTopBlockNode,\n    getPrevTextNode: getPrevTextNode,\n    findOffsetNode: findOffsetNode,\n    getPath: getPath,\n    getNodInfo: getNodeInfo\n};\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"