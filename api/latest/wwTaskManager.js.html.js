tui.util.defineNamespace("fedoc.content", {});
fedoc.content["wwTaskManager.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview Implements wysiwyg task manager\n * @author Sungho Kim(sungho-kim@nhnent.com) FE Development Team/NHN Ent.\n */\n\n'use strict';\n\nvar domUtils = require('./domUtils');\n\nvar FIND_TASK_SPACES_RX = /^[\\s\\u200B]+/;\n\n/**\n * WwTaskManager\n * @exports WwTaskManager\n * @class WwTaskManager\n * @constructor\n * @param {WysiwygEditor} wwe WysiwygEditor instance\n */\nfunction WwTaskManager(wwe) {\n    this.wwe = wwe;\n    this.eventManager = wwe.eventManager;\n\n    this._init();\n}\n\n/**\n * Name property\n * @api\n * @memberOf WwTaskManager\n * @type {string}\n */\nWwTaskManager.prototype.name = 'task';\n\n/**\n * _init\n * Init\n * @memberOf WwTaskManager\n * @private\n */\nWwTaskManager.prototype._init = function() {\n    this._initKeyHandler();\n    this._initEvent();\n};\n\n/**\n * _initEvent\n * Initialize event\n * @memberOf WwTaskManager\n * @private\n */\nWwTaskManager.prototype._initEvent = function() {\n    var self = this;\n\n    this.eventManager.listen('wysiwygRangeChangeAfter', function() {\n        self._removeTaskInputInWrongPlace();\n        self._unformatIncompleteTask();\n        self._ensureSpaceNextToTaskInput();\n    });\n\n    this.eventManager.listen('wysiwygSetValueAfter', function() {\n        self._ensureSpaceNextToTaskInput();\n        self._removeTaskListClass();\n    });\n\n    this.eventManager.listen('wysiwygGetValueBefore', function() {\n        self._addCheckedAttrToCheckedInput();\n    });\n\n    this.eventManager.listen('wysiwygProcessHTMLText', function(html) {\n        //we need remove task input space that made for safari\n        return html.replace(/&lt;input type=\"checkbox\">(\\s|&amp;nbsp;)/g, '&lt;input type=\"checkbox\">');\n    });\n};\n\n/**\n * _initKeyHandler\n * Initialize key event handler\n * @memberOf WwTaskManager\n * @private\n */\nWwTaskManager.prototype._initKeyHandler = function() {\n    var self = this;\n\n    this.wwe.addKeyEventHandler('ENTER', function(ev, range) {\n        if (self.wwe.getEditor().hasFormat('LI')) {\n            //we need unformat task then let Squire control list and make task again\n            //빈 태스크의 경우 input과 태스크상태를 지우고 리스트만 남기고 스콰이어가 리스트를 컨트롤한다\n            //if문에 task가 아닌 li인지를 체크하는것은\n            //현 뎊스가 일반리스트이고 이전뎊스가 태스크인 경우 엔터시 비정상 태스크로 남는것을 방지하기 위함\n            self._unformatTaskIfNeedOnEnter(range);\n\n            self.wwe.defer(function() {\n                self._formatTaskIfNeed();\n            });\n\n            return false;\n        }\n\n        return true;\n    });\n\n    this.wwe.addKeyEventHandler('BACK_SPACE', function(ev, range) {\n        if (range.collapsed) {\n            if (self.isInTaskList(range)) {\n                self._unformatTaskIfNeedOnBackspace(range);\n                //and delete list by squire\n\n                return false;\n            }\n        }\n\n        return true;\n    });\n\n    this.wwe.addKeyEventHandler('TAB', function(ev, range) {\n        if (range.collapsed) {\n            if (self.wwe.getEditor().hasFormat('LI')) {\n                ev.preventDefault();\n                self.eventManager.emit('command', 'IncreaseDepth');\n\n                return false;\n            }\n        }\n\n        return true;\n    });\n\n    this.wwe.addKeyEventHandler('SHIFT+TAB', function(ev, range) {\n        var isNeedNext;\n\n        if (range.collapsed) {\n            if (self.wwe.getEditor().hasFormat('LI')) {\n                ev.preventDefault();\n                self.eventManager.emit('command', 'DecreaseDepth');\n                isNeedNext = false;\n            }\n        }\n\n        return isNeedNext;\n    });\n};\n\n/**\n * isInTaskList\n * Check whether passed range is in task list or not\n * @param {Range} range range\n * @returns {boolean} result\n * @memberOf WwTaskManager\n * @api\n */\nWwTaskManager.prototype.isInTaskList = function(range) {\n    var li;\n\n    if (!range) {\n        range = this.wwe.getEditor().getSelection().cloneRange();\n    }\n\n    if (range.startContainer.nodeType === Node.ELEMENT_NODE\n        &amp;&amp; range.startContainer.tagName === 'LI'\n    ) {\n        li = range.startContainer;\n    } else {\n        li = $(range.startContainer).parents('li')[0];\n    }\n\n    return $(li).hasClass('task-list-item');\n};\n\n/**\n * _unformatIncompleteTask\n * Unformat incomplete task\n * @memberOf WwTaskManager\n * @private\n */\nWwTaskManager.prototype._unformatIncompleteTask = function() {\n    this.wwe.get$Body().find('.task-list-item').each(function(index, task) {\n        if ((!domUtils.isElemNode(task.firstChild) || task.firstChild.tagName !== 'INPUT')\n            &amp;&amp; (!domUtils.isElemNode(task.firstChild.firstChild) || task.firstChild.firstChild.tagName !== 'INPUT')\n        ) {\n            $(task).removeClass('task-list-item');\n        }\n    });\n};\n\n/**\n * _removeTaskInputInWrongPlace\n * Remove task input in wrong place while user editing\n * @memberOf WwTaskManager\n * @private\n */\nWwTaskManager.prototype._removeTaskInputInWrongPlace = function() {\n    var self = this;\n\n    this._addCheckedAttrToCheckedInput();\n\n    this.wwe.get$Body()\n        .find('input:checkbox')\n        .each(function(index, node) {\n            var isInsideTask, isCorrectPlace, parent;\n\n            isInsideTask = ($(node).parents('li').length > 1 || $(node).parents('li').hasClass('task-list-item'));\n            isCorrectPlace = !node.previousSibling;\n\n            if (!isInsideTask || !isCorrectPlace) {\n                parent = $(node).parent();\n                $(node).remove();\n                self.wwe.replaceContentText(parent, FIND_TASK_SPACES_RX, '');\n            }\n        });\n};\n\n/**\n * _unformatTaskIfNeedOnEnter\n * Unformat task if need on enter\n * @param {Range} range range\n * @memberOf WwTaskManager\n * @private\n */\nWwTaskManager.prototype._unformatTaskIfNeedOnEnter = function(range) {\n    var $li;\n\n    $li = $(range.startContainer).closest('li');\n\n    if (this._isEmptyTask(range) &amp;&amp; !$li.find('ul').length) {\n        this.unformatTask(range.startContainer);\n        $li.html('&lt;div>&lt;br>&lt;/div>');\n\n        range = this.wwe.getEditor().getSelection().cloneRange();\n        range.setStart($li.find('div')[0], 0);\n        range.collapse(true);\n        this.wwe.getEditor().setSelection(range);\n    }\n};\n\n/**\n * Return whether task is empty or not\n * @param {Range} range Range object\n * @returns {boolean}\n * @memberOf WwTaskManager\n * @private\n */\nWwTaskManager.prototype._isEmptyTask = function(range) {\n    return this.isInTaskList(range) &amp;&amp; this._isEmptyContainer(range.startContainer);\n};\n\n/**\n * Return whether textContent is empty or not\n * @param {Node} node Node\n * @returns {boolean}\n * @memberOf WwTaskManager\n * @private\n */\nWwTaskManager.prototype._isEmptyContainer = function(node) {\n    return node.textContent.replace(FIND_TASK_SPACES_RX, '') === '';\n};\n\n/**\n * _unformatTaskIfNeedOnBackspace\n * Unformat task if need on backspace\n * @param {Range} range range\n * @memberOf WwTaskManager\n * @private\n */\nWwTaskManager.prototype._unformatTaskIfNeedOnBackspace = function(range) {\n    var startContainer, startOffset,\n        prevEl, needRemove;\n\n    startContainer = range.startContainer;\n    startOffset = range.startOffset;\n\n    //스타트 컨테이너가 엘리먼트인경우 엘리먼트 offset을 기준으로 다음 지워질것이 input인지 판단한다\n    //유저가 임의로 Task빈칸에 수정을 가했을경우\n    if (domUtils.isElemNode(startContainer)) {\n        //태스크리스트의 제일 첫 오프셋인경우(인풋박스 바로 위)\n        if (startOffset === 0) {\n            prevEl = domUtils.getChildNodeByOffset(startContainer, startOffset);\n        //inputbox 오른편 어딘가에서 지워지는경우\n        } else {\n            prevEl = domUtils.getChildNodeByOffset(startContainer, startOffset - 1);\n\n            //지워질위치가 인풋스페이스 텍스트 영역으로 의심되는경우 그다음 엘리먼드로 prevEl을 지정해준다.(그다음이 input이면 지워지도록)\n            if (domUtils.isTextNode(prevEl) &amp;&amp; prevEl.nodeValue.length === 1\n                &amp;&amp; FIND_TASK_SPACES_RX.test(prevEl.nodeValue)) {\n                prevEl = domUtils.getChildNodeByOffset(startContainer, startOffset - 2);\n            }\n        }\n\n        needRemove = (domUtils.getNodeName(prevEl) === 'INPUT');\n    //텍스트 노드인경우\n    } else if (domUtils.isTextNode(startContainer)) {\n        //previousSibling이 있다면 그건 div바로 아래의 텍스트 노드임 아닌경우가생기면 버그\n        //있고 그게 input이라면 offset체크\n        if (startContainer.previousSibling) {\n            prevEl = startContainer.previousSibling;\n        //previsousSibling이 없는 경우, 인라인태그로 감싸져있는경우다\n        } else {\n            prevEl = startContainer.parentNode.previousSibling;\n        }\n\n        //inputbox 이후의 텍스트노드에서 빈칸한개가 지워지는경우 같이 지운다\n        //(input과 빈칸한개는 같이 지워지는게 옳다고판단)\n        if (prevEl.tagName === 'INPUT' &amp;&amp; startOffset === 1 &amp;&amp; FIND_TASK_SPACES_RX.test(startContainer.nodeValue)) {\n            startContainer.nodeValue = startContainer.nodeValue.replace(FIND_TASK_SPACES_RX, '');\n            needRemove = true;\n        }\n    }\n\n    if (needRemove) {\n        this.wwe.saveSelection(range);\n\n        $(prevEl).closest('li').removeClass('task-list-item');\n        $(prevEl).remove();\n\n        this.wwe.restoreSavedSelection();\n    }\n};\n\n/**\n * _addCheckedAttrToCheckedInput\n * Add checked attr to checked input\n * @memberOf WwTaskManager\n * @private\n */\nWwTaskManager.prototype._addCheckedAttrToCheckedInput = function() {\n    var doc = this.wwe.getEditor().getDocument();\n\n    //save input checked state to tag\n    $(doc.body).find('input').each(function(index, input) {\n        if (input.checked) {\n            $(input).attr('checked', 'checked');\n        } else {\n            $(input).removeAttr('checked');\n        }\n    });\n};\n\n/**\n * _removeTaskListClass\n * Remove tasklist class\n * @memberOf WwTaskManager\n * @private\n */\nWwTaskManager.prototype._removeTaskListClass = function() {\n    //because task-list class is block merge normal list and task list\n    this.wwe.get$Body().find('.task-list').each(function(index, node) {\n        $(node).removeClass('task-list');\n    });\n};\n\n\n/**\n * findTextNodeFilter\n * @this Node\n * @returns {boolean} true or not\n */\nfunction findTextNodeFilter() {\n    return this.nodeType === Node.TEXT_NODE;\n}\n\n/**\n * _ensureSpaceNextToTaskInput\n * Ensure space next to task input\n * this because we need some space after input for safari cursor issue\n * @memberOf WwTaskManager\n * @private\n */\nWwTaskManager.prototype._ensureSpaceNextToTaskInput = function() {\n    var firstTextNode, $wrapper,\n        self = this;\n\n    this.wwe.get$Body().find('.task-list-item').each(function(i, node) {\n        $wrapper = $(node).find('div');\n\n        if (!$wrapper.length) {\n            $wrapper = $(node);\n        }\n\n        firstTextNode = $wrapper.contents().filter(findTextNodeFilter)[0];\n\n        if (!firstTextNode || !(firstTextNode.nodeValue.match(FIND_TASK_SPACES_RX))) {\n            $(self.wwe.getEditor().getDocument().createTextNode(' ')).insertAfter($wrapper.find('input'));\n        }\n    });\n};\n\n/**\n * unformatTask\n * Unforamt task\n * @param {Node} node target\n * @memberOf WwTaskManager\n * @api\n */\nWwTaskManager.prototype.unformatTask = function unformatTask(node) {\n    var $li, firstTextNode, $wrapper;\n\n    $li = $(node).closest('li');\n\n    $wrapper = $li.children('div');\n\n    if (!$wrapper.length) {\n        $wrapper = $li;\n    }\n\n    $wrapper.find('input:checkbox').remove();\n\n    $li.removeClass('task-list-item');\n\n    if (!$li.attr('class')) {\n        $li.removeAttr('class');\n    }\n\n    firstTextNode = $wrapper.contents().filter(findTextNodeFilter)[0];\n\n    if (firstTextNode &amp;&amp; firstTextNode.nodeValue.match(FIND_TASK_SPACES_RX)) {\n        firstTextNode.nodeValue = firstTextNode.nodeValue.replace(FIND_TASK_SPACES_RX, '');\n    }\n};\n\n/**\n * formatTask\n * Format task\n * @param {Node} node target\n * @memberOf WwTaskManager\n * @api\n */\nWwTaskManager.prototype.formatTask = function(node) {\n    var range, $selected, $li, hasInput, $block, sq;\n\n    sq = this.wwe.getEditor();\n    $selected = $(node);\n    $li = $selected.closest('li');\n\n    hasInput = $li.children('input:checkbox').length || $li.children('div').eq(0).children('input:checkbox').length;\n\n    $li.addClass('task-list-item');\n\n    if (!hasInput) {\n        $block = $li.children('div').eq(0);\n\n        if (!$block.length) {\n            $block = $li.eq(0);\n        }\n\n        range = sq.getSelection().cloneRange();\n\n        range.setStart($block[0], 0);\n        range.collapse(true);\n\n        sq.insertElement(sq.createElement('INPUT', {\n            type: 'checkbox'\n        }), range);\n\n        range.setStart($block[0], 1);\n\n        //we need some space for safari\n        sq.insertElement(sq.getDocument().createTextNode(' '), range);\n    }\n};\n\n/**\n * _formatTaskIfNeed\n * Format task if current range has task class name\n * @memberOf WwTaskManager\n * @private\n */\nWwTaskManager.prototype._formatTaskIfNeed = function() {\n    var range = this.wwe.getEditor().getSelection().cloneRange();\n\n    if (this.isInTaskList(range)) {\n        range = this.wwe.insertSelectionMarker(range);\n        this.formatTask(range.startContainer);\n        this.wwe.restoreSelectionMarker();\n    }\n};\n\nmodule.exports = WwTaskManager;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"