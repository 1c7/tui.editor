tui.util.defineNamespace("fedoc.content", {});
fedoc.content["extensions_scrollFollow.sectionManager.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview Implements Scroll Follow Extension SectionManager Module\n * @author Sungho Kim(sungho-kim@nhnent.com) FE Development Team/NHN Ent.\n */\n\n'use strict';\n\nvar FIND_HEADER_RX = /^ *(#{1,6}) +([^\\n]+?) *#* *(?:\\n+|$)/,\n    FIND_SETEXT_HEADER_RX = /^ *(?:={1,}|-{1,})\\s*$/,\n    FIND_CODEBLOCK_END_RX = /^ *(`{3,}|~{3,})[ ]*$/,\n    FIND_CODEBLOCK_START_RX = /^ *(`{3,}|~{3,})[ \\.]*(\\S+)? */,\n    FIND_SPACE = /\\s/g;\n\n/**\n * SectionManager\n * manage logical markdown content sections\n * @exports SectionManager\n * @constructor\n * @class\n * @param {CodeMirror} cm codemirror\n * @param {Preview} preview preview\n */\nfunction SectionManager(cm, preview) {\n    this.cm = cm;\n    this.preview = preview;\n    this.$previewContent = preview.$el.find('.tui-editor-contents');\n\n    /**\n     *  section list\n     * @type {object[]}\n     */\n    this._sectionList = null;\n\n    /**\n     * current working section needs making section list\n     * @type {object}\n     */\n    this._currentSection = null;\n}\n\n/**\n * _addNewSection\n * add new section\n * @param {number} start initial start line number\n * @param {number} end initial end line number\n */\nSectionManager.prototype._addNewSection = function(start, end) {\n    var newSection = this._makeSectionData(start, end);\n    this._sectionList.push(newSection);\n    this._currentSection = newSection;\n};\n\n/**\n * getSectionList\n * return section list\n * @returns {object[]} section object list\n */\nSectionManager.prototype.getSectionList = function() {\n    return this._sectionList;\n};\n\n/**\n * _makeSectionData\n * make default section object\n * @param {number} start initial start line number\n * @param {number} end initial end line number\n * @returns {object} section object\n */\nSectionManager.prototype._makeSectionData = function(start, end) {\n    return {\n        start: start,\n        end: end,\n        $previewSectionEl: null\n    };\n};\n\n/**\n * _updateCurrentSectionEnd\n * update current section's end line number\n * @param {number} end end value to update\n */\nSectionManager.prototype._updateCurrentSectionEnd = function(end) {\n    this._currentSection.end = end;\n};\n\n/**\n * _eachLineState\n * iterate codemiror lines, callback function parameter pass line type and line number\n * @param {function} iteratee callback function\n */\nSectionManager.prototype._eachLineState = function(iteratee) {\n    var isSection, i, lineLength, lineString, nextLineString, prevLineString,\n        isTrimming = true,\n        onTable = false,\n        onCodeBlock = false,\n        trimCapture = '';\n\n    lineLength = this.cm.getDoc().lineCount();\n\n    for (i = 0; i &lt; lineLength; i += 1) {\n        isSection = false;\n        lineString = this.cm.getLine(i);\n        nextLineString = this.cm.getLine(i + 1) || '';\n        prevLineString = this.cm.getLine(i - 1) || '';\n\n        if (onTable &amp;&amp; (!lineString || !this._isTableCode(lineString))) {\n            onTable = false;\n        } else if (!onTable &amp;&amp; this._isTable(lineString, nextLineString)) {\n            onTable = true;\n        }\n\n        if (onCodeBlock &amp;&amp; this._isCodeBlockEnd(prevLineString)) {\n            onCodeBlock = false;\n        } else if (!onCodeBlock &amp;&amp; this._isCodeBlockStart(lineString)) {\n            onCodeBlock = this._doFollowedLinesHaveCodeBlockEnd(i, lineLength);\n        }\n\n        //atx header\n        if (this._isAtxHeader(lineString)) {\n            isSection = true;\n        //setext header\n        } else if (!onCodeBlock &amp;&amp; !onTable &amp;&amp; this._isSeTextHeader(lineString, nextLineString)) {\n            isSection = true;\n        }\n\n        //빈공간으로 시작되다다가 헤더를 만난경우 섹션은 두개가 생성되는데\n        //프리뷰에서는 빈공간이 트리밍되어 섹션 한개 밖에 생성되지 않아 매칭이 되지 않는 문제 해결\n        if (isTrimming) {\n            trimCapture += lineString.trim();\n\n            if (trimCapture) {\n                isTrimming = false;\n            } else {\n                continue;\n            }\n        }\n\n        iteratee(isSection, i);\n    }\n};\n\n/**\n * _doFollowedLinesHaveCodeBlockEnd\n * Check if follow lines have codeblock end\n * @param {number} lineIndex current index\n * @param {number} lineLength line length\n * @returns {boolean} result\n */\nSectionManager.prototype._doFollowedLinesHaveCodeBlockEnd = function(lineIndex, lineLength) {\n    var i,\n        doLineHaveCodeBlockEnd = false;\n\n    for (i = lineIndex + 1; i &lt; lineLength; i += 1) {\n        if (this._isCodeBlockEnd(this.cm.getLine(i))) {\n            doLineHaveCodeBlockEnd = true;\n            break;\n        }\n    }\n\n    return doLineHaveCodeBlockEnd;\n};\n\n/**\n * _isCodeBlockStart\n * Check if passed string have code block start\n * @param {string} string string to check\n * @returns {boolean} result\n */\nSectionManager.prototype._isCodeBlockStart = function(string) {\n    return FIND_CODEBLOCK_START_RX.test(string);\n};\n\n/**\n * _isCodeBlockEnd\n * Check if passed string have code block end\n * @param {string} string string to check\n * @returns {boolean} result\n */\nSectionManager.prototype._isCodeBlockEnd = function(string) {\n    return FIND_CODEBLOCK_END_RX.test(string);\n};\n\n/**\n * _isTable\n * Check if passed string have table\n * @param {string} lineString current line string\n * @param {string} nextLineString next line string\n * @returns {boolean} result\n */\nSectionManager.prototype._isTable = function(lineString, nextLineString) {\n    return (this._isTableCode(lineString) &amp;&amp; this._isTableAligner(nextLineString));\n};\n\n/**\n * _isTableCode\n * Check if passed string have table code\n * @param {string} string string to check\n * @returns {boolean} result\n */\nSectionManager.prototype._isTableCode = function(string) {\n    return /(^\\S?.*\\|.*)/.test(string);\n};\n\n/**\n * _isTableAligner\n * Check if passed string have table align code\n * @param {string} string string to check\n * @returns {boolean} result\n */\nSectionManager.prototype._isTableAligner = function(string) {\n    return /(\\s*[-:]+\\s*\\|)+/.test(string);\n};\n\n/**\n * _isAtxHeader\n * Check if passed string have atx header\n * @param {string} string string to check\n * @returns {boolean} result\n */\nSectionManager.prototype._isAtxHeader = function(string) {\n    return FIND_HEADER_RX.test(string);\n};\n\n/**\n * _isSeTextHeader\n * @param {string} lineString current line string\n * @param {string} nextLineString next line string\n * @returns {boolean} result\n */\nSectionManager.prototype._isSeTextHeader = function(lineString, nextLineString) {\n    return lineString.replace(FIND_SPACE, '') !== '' &amp;&amp; nextLineString &amp;&amp; FIND_SETEXT_HEADER_RX.test(nextLineString);\n};\n\n/**\n * makeSectionList\n * make section list\n */\nSectionManager.prototype.makeSectionList = function() {\n    var self = this;\n\n    this._sectionList = [];\n\n    this._eachLineState(function(isSection, lineNumber) {\n        if (isSection || !self._sectionList.length) {\n            self._addNewSection(lineNumber, lineNumber);\n        } else {\n            self._updateCurrentSectionEnd(lineNumber);\n        }\n    });\n};\n\n\n/**\n * sectionMatch\n * make preview sections then match section list with preview section element\n */\nSectionManager.prototype.sectionMatch = function() {\n    var sections;\n\n    if (this._sectionList) {\n        sections = this._getPreviewSections();\n        this._matchPreviewSectionsWithSectionlist(sections);\n    }\n};\n\n/**\n * _matchPreviewSectionsWithSectionlist\n * match section list with preview section element\n * @param {HTMLNode[]} sections section nodes\n */\nSectionManager.prototype._matchPreviewSectionsWithSectionlist = function(sections) {\n    var self = this;\n\n    sections.forEach(function(childs, index) {\n        var $sectionDiv;\n\n        if (self._sectionList[index]) {\n            $sectionDiv = $('&lt;div class=\"content-id-' + index + '\">&lt;/div>');\n            self._sectionList[index].$previewSectionEl = $(childs).wrapAll($sectionDiv).parent();\n        }\n    });\n};\n\n/**\n * findElementNodeFilter\n * @this Node\n * @returns {boolean} true or not\n */\nfunction findElementNodeFilter() {\n    return this.nodeType === Node.ELEMENT_NODE;\n}\n\n/**\n * _getPreviewSections\n * get preview html section group to make section\n * @returns {array[]} element node array\n */\nSectionManager.prototype._getPreviewSections = function() {\n    var lastSection = 0,\n        sections = [];\n\n    sections[0] = [];\n\n    this.$previewContent.contents().filter(findElementNodeFilter).each(function(index, el) {\n        if (el.tagName.match(/H1|H2|H3|H4|H5|H6/)) {\n            if (sections[lastSection].length) {\n                sections.push([]);\n                lastSection += 1;\n            }\n        }\n\n        sections[lastSection].push(el);\n    });\n\n    return sections;\n};\n\n/**\n * _sectionByLine\n * get section by markdown line\n * @param {number} line markdown editor line number\n * @returns {object} section\n */\nSectionManager.prototype.sectionByLine = function(line) {\n    var sectionIndex,\n        sectionList = this._sectionList,\n        sectionLength = sectionList.length;\n\n    for (sectionIndex = 0; sectionIndex &lt; sectionLength; sectionIndex += 1) {\n        if (line &lt;= sectionList[sectionIndex].end) {\n            break;\n        }\n    }\n\n    if (sectionIndex === sectionLength) {\n        sectionIndex = sectionLength - 1;\n    }\n\n    return sectionList[sectionIndex];\n};\n\nmodule.exports = SectionManager;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"