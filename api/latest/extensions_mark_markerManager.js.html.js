tui.util.defineNamespace("fedoc.content", {});
fedoc.content["extensions_mark_markerManager.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>'use strict';\n\nvar DiffMatchPatch = require('../../vendor/diffMatchPatch');\n\nvar util = tui.util;\n\nvar CHANGE_NOTHING = 0,\n    CHANGE_ADD = 1,\n    CHANGE_MINUS = -1;\n\n/**\n * MarkerManager\n * @exports MarkerManager\n * @constructor\n * @class\n * @param {MarkerList} markerList MarkerList object\n */\nfunction MarkerManager(markerList) {\n    this._dmp = new DiffMatchPatch();\n    this.markerList = markerList;\n    this.oldTextContent = null;\n}\n\n/**\n * resetContent\n * Reset content\n * @param {string} content reset base content\n */\nMarkerManager.prototype.resetContent = function(content) {\n    this.oldTextContent = (util.isString(content) ? content : null);\n};\n\n/**\n * uppdateMarkersByContent\n * Get updated markers by updated content\n * @param {string} newContent updated content\n * @returns {object} updated markers\n */\nMarkerManager.prototype.updateMarkersByContent = function(newContent) {\n    var markerDiffs;\n\n    if (util.isNull(this.oldTextContent)) {\n        this.resetContent(newContent);\n\n        return [];\n    }\n\n    markerDiffs = this._makeMarkerDiffs(newContent);\n\n    this.oldTextContent = newContent;\n\n    return this._getUpdateMarkersWithDiffs(markerDiffs);\n};\n\n/**\n * _makeMarkerDiffs\n * Make diffs of marker by updated content\n * @param {string} newContent updated content\n * @returns {object} marker diffs\n */\nMarkerManager.prototype._makeMarkerDiffs = function(newContent) {\n    var markerList = this.markerList,\n        self = this,\n        markerDiffs = {};\n\n    this._forEachChanges(newContent, function(changedStart, changedEnd, diffLen) {\n        markerList.forEachByRangeAffected(changedStart, changedEnd, function(marker) {\n            var markerDiff = markerDiffs[marker.id],\n                startDiff, endDiff;\n\n            startDiff = self._calculateStartDiff(changedStart, changedEnd, diffLen, marker);\n            endDiff = self._calculateEndDiff(changedStart, changedEnd, diffLen, marker);\n\n            if (markerDiff) {\n                markerDiff.start += startDiff;\n                markerDiff.end += endDiff;\n            } else {\n                markerDiffs[marker.id] = {\n                    start: startDiff,\n                    end: endDiff\n                };\n            }\n        });\n    });\n\n    return markerDiffs;\n};\n\n/**\n * _forEachChanges\n * Iterate each change of updated content\n * @param {string} newContent updated content\n * @param {function} iteratee iteratee\n */\nMarkerManager.prototype._forEachChanges = function(newContent, iteratee) {\n    var changedStart = 0,\n        changedEnd = 0,\n        changes = this._dmp.diff_main(this.oldTextContent, newContent);\n\n    changes.forEach(function(change) {\n        var type = change[0],\n            text = change[1],\n            diffLen = 0;\n\n        var changedLen = text.length;\n\n        //이전 변경점 end를 이번 변경점 start로 만들어 위치를 조정한다.\n        changedStart = changedEnd;\n\n        if (type === CHANGE_NOTHING) {\n            changedStart += changedLen;\n            changedEnd += changedLen;\n\n            return;\n        }\n\n        if (type === CHANGE_ADD) {\n            diffLen += changedLen; //더해진경우는 End값이 변경될 필요가없다 변경전의 위치는 start와 end가 collapse일수밖에 없다.. 일반적인 컨트롤상황에서는\n        } else if (type === CHANGE_MINUS) {\n            diffLen -= changedLen;\n            changedEnd += changedLen; //빠지면 빠지기전까지의 범위가 end가 되어야한다.\n        }\n\n        iteratee(changedStart, changedEnd, diffLen);\n    });\n};\n\n/**\n * _calculateStartDiff\n * Calculate start diff\n * @param {number} start change start offset\n * @param {number} end change end offset\n * @param {number} diff diff count of change\n * @param {object} marker marker to calculate diff\n * @returns {number} start diff of marker\n */\nMarkerManager.prototype._calculateStartDiff = function(start, end, diff, marker) {\n    var startDiff;\n\n    // ~AB~[CDE]F\n    if (start &lt;= marker.start &amp;&amp; end &lt;= marker.start) {\n        startDiff = diff;\n    // A~B[C~DE]F\n    } else if (start &lt;= marker.start &amp;&amp; end > marker.start) {\n        startDiff = start - marker.start;\n    } else {\n        startDiff = 0;\n    }\n\n    return startDiff;\n};\n\n/**\n * _calculateEndDiff\n * Calculate end diff\n * @param {number} start change start offset\n * @param {number} end change end offset\n * @param {number} diff diff count of change\n * @param {object} marker marker to calculate diff\n * @returns {number} end diff of marker\n */\nMarkerManager.prototype._calculateEndDiff = function(start, end, diff, marker) {\n    var endDiff;\n\n    // ~AB[CDE~]F\n    if (end &lt;= marker.end) {\n        endDiff = diff;\n    // AB[CD~E]~F\n    } else if (start &lt;= marker.end &amp;&amp; end > marker.start) {\n        endDiff = start - marker.end;\n    } else {\n        endDiff = 0;\n    }\n\n    return endDiff;\n};\n\n/**\n * _getUpdateMarkersWithDiffs\n * Get updated markers with diffs\n * @param {object} markerDiffs marker diff object that contains diff info of specific marker\n * @returns {Array.&lt;object>} updated markers\n */\nMarkerManager.prototype._getUpdateMarkersWithDiffs = function(markerDiffs) {\n    var updatedMarkers = [],\n        markerList = this.markerList;\n\n    util.forEachOwnProperties(markerDiffs, function(markerDiff, id) {\n        var marker = markerList.getMarker(id);\n\n        markerList.updateMarker(id, {\n            start: marker.start += markerDiff.start,\n            end: marker.end += markerDiff.end\n        });\n\n        updatedMarkers.push(marker);\n    });\n\n    return updatedMarkers;\n};\n\nmodule.exports = MarkerManager;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"