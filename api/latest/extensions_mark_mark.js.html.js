tui.util.defineNamespace("fedoc.content", {});
fedoc.content["extensions_mark_mark.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview Implements mark extension for making text marker\n * @author Sungho Kim(sungho-kim@nhnent.com) FE Development Team/NHN Ent.\n */\n\n'use strict';\n\nvar extManager = require('../../extManager'),\n    MarkerList = require('./markerList'),\n    MarkerManager = require('./markerManager'),\n    WysiwygMarkerHelper = require('./wysiwygMarkerHelper'),\n    ViewOnlyMarkerHelper = require('./viewOnlyMarkerHelper'),\n    MarkdownMarkerHelper = require('./markdownMarkerHelper');\n\nvar util = tui.util;\n\nvar MARKER_UPDATE_DELAY = 100,\n    FIND_CRLF_RX = /(\\n)|(\\r\\n)|(\\r)/g;\n\n/**\n * Mark Extension\n * Define marker extension\n */\nextManager.defineExtension('mark', function(editor) {\n    var ml = new MarkerList(),\n        mm = new MarkerManager(ml),\n        wmh, mmh, vmh;\n\n    editor.eventManager.addEventType('markerUpdated');\n\n    if (editor.isViewOnly()) {\n        vmh = new ViewOnlyMarkerHelper(editor.preview);\n    } else {\n        wmh = new WysiwygMarkerHelper(editor.getSquire());\n        mmh = new MarkdownMarkerHelper(editor.getCodeMirror());\n    }\n\n    /**\n     * getHelper\n     * Get helper for current situation\n     * @returns {object} helper\n     */\n    function getHelper() {\n        var helper;\n\n        if (editor.isViewOnly()) {\n            helper = vmh;\n        } else if (editor.isWysiwygMode()) {\n            helper = wmh;\n        } else {\n            helper = mmh;\n        }\n\n        return helper;\n    }\n\n    function updateMarkWhenResizing() {\n        var helper = getHelper();\n\n        ml.getAll().forEach(function(marker) {\n            helper.updateMarkerWithExtraInfo(marker);\n        });\n\n        editor.eventManager.emit('markerUpdated', ml.getAll());\n    }\n\n    //We need to update marker after window have been resized\n    $(window).on('resize', updateMarkWhenResizing);\n\n    editor.on('removeEditor', function() {\n        $(window).off('resize', updateMarkWhenResizing);\n    });\n\n    //Reset marker content after set value\n    editor.on('setValueAfter', function() {\n        var helper = getHelper();\n        mm.resetContent(helper.getTextContent());\n    });\n\n    /**\n     * setValueWithMarkers\n     * Set value with markers\n     * @param {string} value markdown content\n     * @param {object} markerDataCollection marker data that obtain with exportMarkers method\n     * @returns {Array.&lt;object>} markers\n     */\n    editor.setValueWithMarkers = function(value, markerDataCollection) {\n        var helper;\n\n        ml.resetMarkers();\n\n        markerDataCollection.forEach(function(markerData) {\n            ml.addMarker(markerData.start, markerData.end, markerData.id);\n        });\n\n        editor.setValue(value);\n\n        mm.resetContent(value.replace(FIND_CRLF_RX, ''));\n\n        if (this.isViewOnly() || this.isWysiwygMode()) {\n            helper = getHelper();\n            mm.updateMarkersByContent(helper.getTextContent());\n        } else {\n            helper = mmh;\n        }\n\n        ml.getAll().forEach(function(marker) {\n            helper.updateMarkerWithExtraInfo(marker);\n        });\n\n        this.eventManager.emit('markerUpdated', ml.getAll());\n\n        return ml.getAll();\n    };\n\n    /**\n     * getMarker\n     * Get markers that have given id\n     * @param {string} id id of marker\n     * @returns {object}\n     */\n    editor.getMarker = function(id) {\n        return ml.getMarker(id);\n    };\n\n    /**\n     * getMarkersAll\n     * Get all markers\n     * @returns {Array.&lt;object>}\n     */\n    editor.getMarkersAll = function() {\n        return ml.getAll();\n    };\n\n    /**\n     * removeMarker\n     * Remove marker with given id\n     * @param {string} id of marker that should be removed\n     * @returns {marker} removed marker\n     */\n    editor.removeMarker = function(id) {\n        return ml.removeMarker(id);\n    };\n\n    /**\n     * getMarkersData\n     * Get marker data to export so you can restore markers next time\n     * @returns {object} markers data\n     */\n    editor.exportMarkers = function() {\n        var markersData;\n\n        if (this.isMarkdownMode()) {\n            markersData = ml.getMarkersData();\n        } else if (this.isViewOnly() || this.isWysiwygMode()) {\n            mm.updateMarkersByContent(this.getValue().replace(FIND_CRLF_RX, ''));\n            markersData = ml.getMarkersData();\n            mm.updateMarkersByContent(getHelper().getTextContent());\n        }\n\n        return markersData;\n    };\n\n    /**\n     * selectMarker\n     * Make selection with marker that have given id\n     * @param {string} id id of marker\n     */\n    editor.selectMarker = function(id) {\n        var helper = getHelper(),\n            marker = this.getMarker(id);\n\n        if (marker) {\n            helper.selectOffsetRange(marker.start, marker.end);\n        }\n    };\n\n    /**\n     * addMarker\n     * Add Marker with given id\n     * if you pass just id then it uses current selection for marker\n     * or you can pass start and end offset for marker\n     * @param {number|string} start start offset or id\n     * @param {number} end end offset\n     * @param {string} id id of marker\n     * @returns {object} marker that have made\n     */\n    editor.addMarker = function(start, end, id) {\n        var marker,\n            helper = getHelper();\n\n        if (!id) {\n            id = start;\n            marker = helper.getMarkerInfoOfCurrentSelection();\n        } else {\n            marker = {\n                start: start,\n                end: end\n            };\n\n            marker = helper.updateMarkerWithExtraInfo(marker);\n        }\n\n        if (marker) {\n            marker.id = id;\n            marker = ml.addMarker(marker);\n            ml.sortBy('end');\n            this.eventManager.emit('markerUpdated', [marker]);\n        }\n\n        return marker;\n    };\n\n    /**\n     * clearSelect\n     * Clear selection\n     */\n    editor.clearSelect = function() {\n        getHelper().clearSelect();\n    };\n\n    if (!editor.isViewOnly()) {\n        editor.on('changeMode', function() {\n            editor._updateMarkers();\n        });\n\n        editor.on('change', util.debounce(function() {\n            editor._updateMarkers();\n        }, MARKER_UPDATE_DELAY));\n\n        /**\n         * _updateMarkers\n         * Update markers with current text content\n         */\n        editor._updateMarkers = function() {\n            var helper = getHelper();\n\n            if (!ml.getAll().length) {\n                return;\n            }\n\n            mm.updateMarkersByContent(helper.getTextContent());\n\n            ml.getAll().forEach(function(marker) {\n                helper.updateMarkerWithExtraInfo(marker);\n            });\n\n            editor.eventManager.emit('markerUpdated', ml.getAll());\n        };\n    }\n});\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"