

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Source: wwTableManager.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/bootstrap.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-jsdoc.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/tui-doc.css">
</head>
<body>
<nav class="lnb" id="lnb">
    <div class="logo" style="">
        <img src="img/toast-ui.png" width="100%" height="100%">
    </div>
    <div class="title">
        <h1><a href="index.html" class="link">Source: wwTableManager.js</a></h1>
        
    </div>
    <div class="search-container" id="search-container">
        <input type="text" placeholder="Search">
        <ul></ul>
    </div>
    
    <div class="lnb-api hidden"><h3>Classes</h3><ul><li><a href="CodeBlockManager.html">CodeBlockManager</a><div class="hidden" id="CodeBlockManager_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="CodeBlockManager.html#.getSharedInstance">getSharedInstance</a></li><li><a href="CodeBlockManager.html#createCodeBlockHtml">createCodeBlockHtml</a></li><li><a href="CodeBlockManager.html#replaceElements">replaceElements</a></li><li><a href="CodeBlockManager.html#setElementReplacer">setElementReplacer</a></li><li><a href="CodeBlockManager.html#updateCodeTextById">updateCodeTextById</a></li></ul></div></li><li><a href="Command.html">Command</a><div class="hidden" id="Command_sub"><div class="member-type">Members</div><ul class="inner"><li><a href="Command.html#.TYPE">TYPE</a></li></ul><div class="member-type">Methods</div><ul class="inner"><li><a href="Command.html#.factory">factory</a></li><li><a href="Command.html#getName">getName</a></li><li><a href="Command.html#getType">getType</a></li><li><a href="Command.html#isGlobalType">isGlobalType</a></li><li><a href="Command.html#isMDType">isMDType</a></li><li><a href="Command.html#isWWType">isWWType</a></li><li><a href="Command.html#setKeyMap">setKeyMap</a></li></ul></div></li><li><a href="CommandManager.html">CommandManager</a><div class="hidden" id="CommandManager_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="CommandManager.html#addCommand">addCommand</a></li><li><a href="CommandManager.html#exec">exec</a></li></ul></div></li><li><a href="ComponentManager.html">ComponentManager</a><div class="hidden" id="ComponentManager_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="ComponentManager.html#.CommandManager.command">CommandManager.command</a></li><li><a href="ComponentManager.html#addManager">addManager</a></li><li><a href="ComponentManager.html#getManager">getManager</a></li><li><a href="ComponentManager.html#removeManager">removeManager</a></li></ul></div></li><li><a href="Convertor.html">Convertor</a><div class="hidden" id="Convertor_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="Convertor.html#.factory">factory</a></li><li><a href="Convertor.html#.getMarkdownHighlightRenderer">getMarkdownHighlightRenderer</a></li><li><a href="Convertor.html#toHTML">toHTML</a></li><li><a href="Convertor.html#toHTMLWithCodeHightlight">toHTMLWithCodeHightlight</a></li><li><a href="Convertor.html#toMarkdown">toMarkdown</a></li></ul></div></li><li><a href="EventManager.html">EventManager</a><div class="hidden" id="EventManager_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="EventManager.html#addEventType">addEventType</a></li><li><a href="EventManager.html#emit">emit</a></li><li><a href="EventManager.html#emitReduce">emitReduce</a></li><li><a href="EventManager.html#listen">listen</a></li><li><a href="EventManager.html#removeEventHandler">removeEventHandler</a></li></ul></div></li><li><a href="ExtManager.html">ExtManager</a><div class="hidden" id="ExtManager_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="ExtManager.html#applyExtension">applyExtension</a></li><li><a href="ExtManager.html#defineExtension">defineExtension</a></li></ul></div></li><li><a href="I18n.html">I18n</a><div class="hidden" id="I18n_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="I18n.html#get">get</a></li><li><a href="I18n.html#setCode">setCode</a></li><li><a href="I18n.html#setLang">setLang</a></li></ul></div></li><li><a href="ImportManager.html">ImportManager</a><div class="hidden" id="ImportManager_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="ImportManager.html#_decodeURL">_decodeURL</a></li></ul></div></li><li><a href="KeyMapper.html">KeyMapper</a><div class="hidden" id="KeyMapper_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="KeyMapper.html#.getSharedInstance">getSharedInstance</a></li><li><a href="KeyMapper.html#convert">convert</a></li></ul></div></li><li><a href="Layout.html">Layout</a><div class="hidden" id="Layout_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="Layout.html#changePreviewStyle">changePreviewStyle</a></li><li><a href="Layout.html#getEditorEl">getEditorEl</a></li><li><a href="Layout.html#getMdEditorContainerEl">getMdEditorContainerEl</a></li><li><a href="Layout.html#getPreviewEl">getPreviewEl</a></li><li><a href="Layout.html#getWwEditorContainerEl">getWwEditorContainerEl</a></li><li><a href="Layout.html#hide">hide</a></li><li><a href="Layout.html#init">init</a></li><li><a href="Layout.html#remove">remove</a></li><li><a href="Layout.html#show">show</a></li><li><a href="Layout.html#switchToMarkdown">switchToMarkdown</a></li><li><a href="Layout.html#switchToWYSIWYG">switchToWYSIWYG</a></li></ul></div></li><li><a href="MarkdownEditor.html">MarkdownEditor</a><div class="hidden" id="MarkdownEditor_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="MarkdownEditor.html#.factory">factory</a></li><li><a href="MarkdownEditor.html#addWidget">addWidget</a></li><li><a href="MarkdownEditor.html#blur">blur</a></li><li><a href="MarkdownEditor.html#focus">focus</a></li><li><a href="MarkdownEditor.html#getCaretPosition">getCaretPosition</a></li><li><a href="MarkdownEditor.html#getCurrentRange">getCurrentRange</a></li><li><a href="MarkdownEditor.html#getEditor">getEditor</a></li><li><a href="MarkdownEditor.html#getRange">getRange</a></li><li><a href="MarkdownEditor.html#getTextObject">getTextObject</a></li><li><a href="MarkdownEditor.html#getValue">getValue</a></li><li><a href="MarkdownEditor.html#moveCursorToEnd">moveCursorToEnd</a></li><li><a href="MarkdownEditor.html#moveCursorToStart">moveCursorToStart</a></li><li><a href="MarkdownEditor.html#remove">remove</a></li><li><a href="MarkdownEditor.html#replaceRelativeOffset">replaceRelativeOffset</a></li><li><a href="MarkdownEditor.html#replaceSelection">replaceSelection</a></li><li><a href="MarkdownEditor.html#reset">reset</a></li><li><a href="MarkdownEditor.html#scrollTop">scrollTop</a></li><li><a href="MarkdownEditor.html#setHeight">setHeight</a></li><li><a href="MarkdownEditor.html#setValue">setValue</a></li></ul></div></li><li><a href="MarkerManager.html">MarkerManager</a><div class="hidden" id="MarkerManager_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="MarkerManager.html#_calculateEndDiff">_calculateEndDiff</a></li><li><a href="MarkerManager.html#_calculateStartDiff">_calculateStartDiff</a></li><li><a href="MarkerManager.html#_forEachChanges">_forEachChanges</a></li><li><a href="MarkerManager.html#_getUpdateMarkersWithDiffs">_getUpdateMarkersWithDiffs</a></li><li><a href="MarkerManager.html#_makeMarkerDiffs">_makeMarkerDiffs</a></li><li><a href="MarkerManager.html#resetContent">resetContent</a></li><li><a href="MarkerManager.html#updateMarkersByContent">updateMarkersByContent</a></li></ul></div></li><li><a href="MdListManager.html">MdListManager</a><div class="hidden" id="MdListManager_sub"><div class="member-type">Members</div><ul class="inner"><li><a href="MdListManager.html#.this.name">this.name</a></li></ul><div class="member-type">Methods</div><ul class="inner"><li><a href="MdListManager.html#appendBlankLineIfNeed">appendBlankLineIfNeed</a></li><li><a href="MdListManager.html#createSortedLineRange">createSortedLineRange</a></li><li><a href="MdListManager.html#expandLineRangeIfNeed">expandLineRangeIfNeed</a></li><li><a href="MdListManager.html#isListOrParagraph">isListOrParagraph</a></li><li><a href="MdListManager.html#replaceLineText">replaceLineText</a></li></ul></div></li><li><a href="Preview.html">Preview</a><div class="hidden" id="Preview_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="Preview.html#isVisible">isVisible</a></li><li><a href="Preview.html#refresh">refresh</a></li><li><a href="Preview.html#render">render</a></li><li><a href="Preview.html#setHeight">setHeight</a></li></ul></div></li><li><a href="SectionManager.html">SectionManager</a><div class="hidden" id="SectionManager_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="SectionManager.html#_addNewSection">_addNewSection</a></li><li><a href="SectionManager.html#_doFollowedLinesHaveCodeBlockEnd">_doFollowedLinesHaveCodeBlockEnd</a></li><li><a href="SectionManager.html#_eachLineState">_eachLineState</a></li><li><a href="SectionManager.html#_getPreviewSections">_getPreviewSections</a></li><li><a href="SectionManager.html#_isAtxHeader">_isAtxHeader</a></li><li><a href="SectionManager.html#_isCodeBlockEnd">_isCodeBlockEnd</a></li><li><a href="SectionManager.html#_isCodeBlockStart">_isCodeBlockStart</a></li><li><a href="SectionManager.html#_isSeTextHeader">_isSeTextHeader</a></li><li><a href="SectionManager.html#_isTable">_isTable</a></li><li><a href="SectionManager.html#_isTableAligner">_isTableAligner</a></li><li><a href="SectionManager.html#_isTableCode">_isTableCode</a></li><li><a href="SectionManager.html#_makeSectionData">_makeSectionData</a></li><li><a href="SectionManager.html#_matchPreviewSectionsWithSectionlist">_matchPreviewSectionsWithSectionlist</a></li><li><a href="SectionManager.html#_updateCurrentSectionEnd">_updateCurrentSectionEnd</a></li><li><a href="SectionManager.html#getSectionList">getSectionList</a></li><li><a href="SectionManager.html#makeSectionList">makeSectionList</a></li><li><a href="SectionManager.html#sectionByLine">sectionByLine</a></li><li><a href="SectionManager.html#sectionMatch">sectionMatch</a></li></ul></div></li><li><a href="ToastUIEditor.html">ToastUIEditor</a><div class="hidden" id="ToastUIEditor_sub"><div class="member-type">Members</div><ul class="inner"><li><a href="ToastUIEditor.html#.i18n">i18n</a></li><li><a href="ToastUIEditor.html#.markdownItRenderer">markdownItRenderer</a></li></ul><div class="member-type">Methods</div><ul class="inner"><li><a href="ToastUIEditor.html#.defineExtension">defineExtension</a></li><li><a href="ToastUIEditor.html#.factory">factory</a></li><li><a href="ToastUIEditor.html#.getInstances">getInstances</a></li><li><a href="ToastUIEditor.html#addHook">addHook</a></li><li><a href="ToastUIEditor.html#addWidget">addWidget</a></li><li><a href="ToastUIEditor.html#afterAddedCommand">afterAddedCommand</a></li><li><a href="ToastUIEditor.html#blur">blur</a></li><li><a href="ToastUIEditor.html#changeMode">changeMode</a></li><li><a href="ToastUIEditor.html#changePreviewStyle">changePreviewStyle</a></li><li><a href="ToastUIEditor.html#contentHeight">contentHeight</a></li><li><a href="ToastUIEditor.html#exec">exec</a></li><li><a href="ToastUIEditor.html#focus">focus</a></li><li><a href="ToastUIEditor.html#getCodeMirror">getCodeMirror</a></li><li><a href="ToastUIEditor.html#getCurrentModeEditor">getCurrentModeEditor</a></li><li><a href="ToastUIEditor.html#getCurrentPreviewStyle">getCurrentPreviewStyle</a></li><li><a href="ToastUIEditor.html#getHtml">getHtml</a></li><li><a href="ToastUIEditor.html#getMarkdown">getMarkdown</a></li><li><a href="ToastUIEditor.html#getRange">getRange</a></li><li><a href="ToastUIEditor.html#getSquire">getSquire</a></li><li><a href="ToastUIEditor.html#getTextObject">getTextObject</a></li><li><a href="ToastUIEditor.html#getUI">getUI</a></li><li><a href="ToastUIEditor.html#getValue">getValue</a></li><li><a href="ToastUIEditor.html#hide">hide</a></li><li><a href="ToastUIEditor.html#isMarkdownMode">isMarkdownMode</a></li><li><a href="ToastUIEditor.html#isViewOnly">isViewOnly</a></li><li><a href="ToastUIEditor.html#isWysiwygMode">isWysiwygMode</a></li><li><a href="ToastUIEditor.html#moveCursorToEnd">moveCursorToEnd</a></li><li><a href="ToastUIEditor.html#moveCursorToStart">moveCursorToStart</a></li><li><a href="ToastUIEditor.html#off">off</a></li><li><a href="ToastUIEditor.html#on">on</a></li><li><a href="ToastUIEditor.html#remove">remove</a></li><li><a href="ToastUIEditor.html#removeHook">removeHook</a></li><li><a href="ToastUIEditor.html#reset">reset</a></li><li><a href="ToastUIEditor.html#scrollTop">scrollTop</a></li><li><a href="ToastUIEditor.html#setHtml">setHtml</a></li><li><a href="ToastUIEditor.html#setMarkdown">setMarkdown</a></li><li><a href="ToastUIEditor.html#setUI">setUI</a></li><li><a href="ToastUIEditor.html#setValue">setValue</a></li><li><a href="ToastUIEditor.html#show">show</a></li></ul></div></li><li><a href="ToastUIEditorViewOnly.html">ToastUIEditorViewOnly</a><div class="hidden" id="ToastUIEditorViewOnly_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="ToastUIEditorViewOnly.html#addHook">addHook</a></li><li><a href="ToastUIEditorViewOnly.html#isMarkdownMode">isMarkdownMode</a></li><li><a href="ToastUIEditorViewOnly.html#isViewOnly">isViewOnly</a></li><li><a href="ToastUIEditorViewOnly.html#isWysiwygMode">isWysiwygMode</a></li><li><a href="ToastUIEditorViewOnly.html#off">off</a></li><li><a href="ToastUIEditorViewOnly.html#on">on</a></li><li><a href="ToastUIEditorViewOnly.html#remove">remove</a></li><li><a href="ToastUIEditorViewOnly.html#setMarkdown">setMarkdown</a></li><li><a href="ToastUIEditorViewOnly.html#setValue">setValue</a></li></ul></div></li><li><a href="WwClipboardManager.html">WwClipboardManager</a><div class="hidden" id="WwClipboardManager_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="WwClipboardManager.html#init">init</a></li></ul></div></li><li><a href="WwCodeBlockManager.html">WwCodeBlockManager</a><div class="hidden" id="WwCodeBlockManager_sub"><div class="member-type">Members</div><ul class="inner"><li><a href="WwCodeBlockManager.html#.this.name">this.name</a></li></ul><div class="member-type">Methods</div><ul class="inner"><li><a href="WwCodeBlockManager.html#convertToCodeblock">convertToCodeblock</a></li><li><a href="WwCodeBlockManager.html#isInCodeBlock">isInCodeBlock</a></li><li><a href="WwCodeBlockManager.html#prepareToPasteOnCodeblock">prepareToPasteOnCodeblock</a></li></ul></div></li><li><a href="WwHeadingManager.html">WwHeadingManager</a><div class="hidden" id="WwHeadingManager_sub"><div class="member-type">Members</div><ul class="inner"><li><a href="WwHeadingManager.html#.this.name">this.name</a></li></ul></div></li><li><a href="WwHrManager.html">WwHrManager</a><div class="hidden" id="WwHrManager_sub"><div class="member-type">Members</div><ul class="inner"><li><a href="WwHrManager.html#.this.name">this.name</a></li></ul></div></li><li><a href="WwListManager.html">WwListManager</a><div class="hidden" id="WwListManager_sub"><div class="member-type">Members</div><ul class="inner"><li><a href="WwListManager.html#.this.name">this.name</a></li></ul></div></li><li><a href="WwMergedTableManager.html">WwMergedTableManager</a><div class="hidden" id="WwMergedTableManager_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="WwMergedTableManager.html#prepareToTableCellStuffing">prepareToTableCellStuffing</a></li><li><a href="WwMergedTableManager.html#tableCellAppendAidForTableElement">tableCellAppendAidForTableElement</a></li></ul></div></li><li><a href="WwMergedTableSelectionManager.html">WwMergedTableSelectionManager</a><div class="hidden" id="WwMergedTableSelectionManager_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="WwMergedTableSelectionManager.html#hasSelectedBothThAndTd">hasSelectedBothThAndTd</a></li><li><a href="WwMergedTableSelectionManager.html#highlightTableCellsBy">highlightTableCellsBy</a></li><li><a href="WwMergedTableSelectionManager.html#setTableSelectionTimerIfNeed">setTableSelectionTimerIfNeed</a></li><li><a href="WwMergedTableSelectionManager.html#styleToSelectedCells">styleToSelectedCells</a></li></ul></div></li><li><a href="WwPasteContentHelper.html">WwPasteContentHelper</a><div class="hidden" id="WwPasteContentHelper_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="WwPasteContentHelper.html#preparePaste">preparePaste</a></li></ul></div></li><li><a href="WwPManager.html">WwPManager</a><div class="hidden" id="WwPManager_sub"><div class="member-type">Members</div><ul class="inner"><li><a href="WwPManager.html#.this.name">this.name</a></li></ul><div class="member-type">Methods</div><ul class="inner"><li><a href="WwPManager.html#_splitPtagContentLines">_splitPtagContentLines</a></li></ul></div></li><li><a href="WwTableManager.html">WwTableManager</a><div class="hidden" id="WwTableManager_sub"><div class="member-type">Members</div><ul class="inner"><li><a href="WwTableManager.html#.this.name">this.name</a></li></ul><div class="member-type">Methods</div><ul class="inner"><li><a href="WwTableManager.html#_changeSelectionToTargetCell">_changeSelectionToTargetCell</a></li><li><a href="WwTableManager.html#_onPaste">_onPaste</a></li><li><a href="WwTableManager.html#destroy">destroy</a></li><li><a href="WwTableManager.html#getTableIDClassName">getTableIDClassName</a></li><li><a href="WwTableManager.html#isInTable">isInTable</a></li><li><a href="WwTableManager.html#isNonTextDeleting">isNonTextDeleting</a></li><li><a href="WwTableManager.html#prepareToPasteOnTable">prepareToPasteOnTable</a></li><li><a href="WwTableManager.html#prepareToTableCellStuffing">prepareToTableCellStuffing</a></li><li><a href="WwTableManager.html#resetLastCellNode">resetLastCellNode</a></li><li><a href="WwTableManager.html#setLastCellNode">setLastCellNode</a></li><li><a href="WwTableManager.html#tableCellAppendAidForTableElement">tableCellAppendAidForTableElement</a></li><li><a href="WwTableManager.html#wrapDanglingTableCellsIntoTrIfNeed">wrapDanglingTableCellsIntoTrIfNeed</a></li><li><a href="WwTableManager.html#wrapTheadAndTbodyIntoTableIfNeed">wrapTheadAndTbodyIntoTableIfNeed</a></li><li><a href="WwTableManager.html#wrapTrsIntoTbodyIfNeed">wrapTrsIntoTbodyIfNeed</a></li></ul></div></li><li><a href="WwTableSelectionManager.html">WwTableSelectionManager</a><div class="hidden" id="WwTableSelectionManager_sub"><div class="member-type">Members</div><ul class="inner"><li><a href="WwTableSelectionManager.html#.this.name">this.name</a></li></ul><div class="member-type">Methods</div><ul class="inner"><li><a href="WwTableSelectionManager.html#destroy">destroy</a></li><li><a href="WwTableSelectionManager.html#getSelectionRangeFromTable">getSelectionRangeFromTable</a></li><li><a href="WwTableSelectionManager.html#highlightTableCellsBy">highlightTableCellsBy</a></li><li><a href="WwTableSelectionManager.html#removeClassAttrbuteFromAllCellsIfNeed">removeClassAttrbuteFromAllCellsIfNeed</a></li><li><a href="WwTableSelectionManager.html#setTableSelectionTimerIfNeed">setTableSelectionTimerIfNeed</a></li><li><a href="WwTableSelectionManager.html#styleToSelectedCells">styleToSelectedCells</a></li></ul></div></li><li><a href="WwTaskManager.html">WwTaskManager</a><div class="hidden" id="WwTaskManager_sub"><div class="member-type">Members</div><ul class="inner"><li><a href="WwTaskManager.html#.this.name">this.name</a></li></ul><div class="member-type">Methods</div><ul class="inner"><li><a href="WwTaskManager.html#formatTask">formatTask</a></li><li><a href="WwTaskManager.html#isInTaskList">isInTaskList</a></li><li><a href="WwTaskManager.html#unformatTask">unformatTask</a></li></ul></div></li><li><a href="WwTextObject.html">WwTextObject</a><div class="hidden" id="WwTextObject_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="WwTextObject.html#deleteContent">deleteContent</a></li><li><a href="WwTextObject.html#expandEndOffset">expandEndOffset</a></li><li><a href="WwTextObject.html#expandStartOffset">expandStartOffset</a></li><li><a href="WwTextObject.html#getTextContent">getTextContent</a></li><li><a href="WwTextObject.html#peekStartBeforeOffset">peekStartBeforeOffset</a></li><li><a href="WwTextObject.html#replaceContent">replaceContent</a></li><li><a href="WwTextObject.html#setEndBeforeRange">setEndBeforeRange</a></li><li><a href="WwTextObject.html#setRange">setRange</a></li></ul></div></li><li><a href="WysiwygEditor.html">WysiwygEditor</a><div class="hidden" id="WysiwygEditor_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="WysiwygEditor.html#.factory">factory</a></li><li><a href="WysiwygEditor.html#.MarkdownEditor#init">MarkdownEditor#init</a></li><li><a href="WysiwygEditor.html#addKeyEventHandler">addKeyEventHandler</a></li><li><a href="WysiwygEditor.html#addWidget">addWidget</a></li><li><a href="WysiwygEditor.html#blur">blur</a></li><li><a href="WysiwygEditor.html#breakToNewDefaultBlock">breakToNewDefaultBlock</a></li><li><a href="WysiwygEditor.html#changeBlockFormatTo">changeBlockFormatTo</a></li><li><a href="WysiwygEditor.html#findTextNodeFilter">findTextNodeFilter</a></li><li><a href="WysiwygEditor.html#focus">focus</a></li><li><a href="WysiwygEditor.html#get$Body">get$Body</a></li><li><a href="WysiwygEditor.html#getEditor">getEditor</a></li><li><a href="WysiwygEditor.html#getRange">getRange</a></li><li><a href="WysiwygEditor.html#getTextObject">getTextObject</a></li><li><a href="WysiwygEditor.html#getValue">getValue</a></li><li><a href="WysiwygEditor.html#hasFormatWithRx">hasFormatWithRx</a></li><li><a href="WysiwygEditor.html#init">init</a></li><li><a href="WysiwygEditor.html#makeEmptyBlockCurrentSelection">makeEmptyBlockCurrentSelection</a></li><li><a href="WysiwygEditor.html#moveCursorToEnd">moveCursorToEnd</a></li><li><a href="WysiwygEditor.html#moveCursorToStart">moveCursorToStart</a></li><li><a href="WysiwygEditor.html#readySilentChange">readySilentChange</a></li><li><a href="WysiwygEditor.html#remove">remove</a></li><li><a href="WysiwygEditor.html#removeKeyEventHandler">removeKeyEventHandler</a></li><li><a href="WysiwygEditor.html#replaceContentText">replaceContentText</a></li><li><a href="WysiwygEditor.html#replaceRelativeOffset">replaceRelativeOffset</a></li><li><a href="WysiwygEditor.html#replaceSelection">replaceSelection</a></li><li><a href="WysiwygEditor.html#reset">reset</a></li><li><a href="WysiwygEditor.html#restoreSavedSelection">restoreSavedSelection</a></li><li><a href="WysiwygEditor.html#saveSelection">saveSelection</a></li><li><a href="WysiwygEditor.html#scrollTop">scrollTop</a></li><li><a href="WysiwygEditor.html#setHeight">setHeight</a></li><li><a href="WysiwygEditor.html#setValue">setValue</a></li><li><a href="WysiwygEditor.html#unwrapBlockTag">unwrapBlockTag</a></li></ul></div></li><li><a href="WysiwygMarkerHelper.html">WysiwygMarkerHelper</a><div class="hidden" id="WysiwygMarkerHelper_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="WysiwygMarkerHelper.html#_extendRangeToTextNodeIfHasNone">_extendRangeToTextNodeIfHasNone</a></li><li><a href="WysiwygMarkerHelper.html#_findOffsetNode">_findOffsetNode</a></li><li><a href="WysiwygMarkerHelper.html#_getExtraInfoOfRange">_getExtraInfoOfRange</a></li><li><a href="WysiwygMarkerHelper.html#clearSelect">clearSelect</a></li><li><a href="WysiwygMarkerHelper.html#getMarkerInfoOfCurrentSelection">getMarkerInfoOfCurrentSelection</a></li><li><a href="WysiwygMarkerHelper.html#getTextContent">getTextContent</a></li><li><a href="WysiwygMarkerHelper.html#selectOffsetRange">selectOffsetRange</a></li><li><a href="WysiwygMarkerHelper.html#updateMarkerWithExtraInfo">updateMarkerWithExtraInfo</a></li></ul></div></li></ul></div>
</nav>
<div id="resizer"></div>

<div class="main" id="main">
    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @fileoverview Implements wysiwyg table manager
 * @author Sungho Kim(sungho-kim@nhnent.com) FE Development Lab/NHN Ent.
 * @author Junghwan Park(junghwan.park@nhnent.com) FE Development Lab/NHN Ent.
 */


import domUtils from './domUtils';
const util = tui.util;
const isIE10 = util.browser.msie &amp;&amp; util.browser.version === 10;
const TABLE_COMPLETION_DELAY = 10;
const SET_SELECTION_DELAY = 50;
const TABLE_CLASS_PREFIX = 'te-content-table-';
const isIE10And11 = util.browser.msie
    &amp;&amp; (util.browser.version === 10 || util.browser.version === 11);

/**
 * WwTableManager
 * @exports WwTableManager
 * @constructor
 * @class WwTableManager
 * @param {WysiwygEditor} wwe WysiwygEditor instance
 */
class WwTableManager {
    constructor(wwe) {
        this.wwe = wwe;
        this.eventManager = wwe.eventManager;

        /**
         * Name property
         * @api
         * @memberOf WwTableManager
         * @type {string}
         */
        this.name = 'table';

        this._lastCellNode = null;
        this._init();
    }

    /**
     * _init
     * Initialize
     * @memberOf WwTableManager
     * @private
     */
    _init() {
        this._initKeyHandler();
        this._initEvent();
        this.tableID = 0;
    }

    /**
     * _initEvent
     * Initialize event
     * @memberOf WwTableManager
     * @private
     */
    _initEvent() {
        this.eventManager.listen('wysiwygRangeChangeAfter.table', () => {
            this._unwrapBlockInTable();
            this.wwe.defer(() => {
                this._completeTableIfNeed();
            }, TABLE_COMPLETION_DELAY);
            this.wwe.componentManager.getManager('tableSelection').removeClassAttrbuteFromAllCellsIfNeed();
            this._insertDefaultBlockBetweenTable();
        });

        this.eventManager.listen('wysiwygSetValueAfter.table', () => {
            this._unwrapBlockInTable();
            this._insertDefaultBlockBetweenTable();
        });

        // remove last br in td or th
        this.eventManager.listen('wysiwygProcessHTMLText.table', html => html.replace(/&lt;br \/>(&lt;\/td>|&lt;\/th>)/g, '$1'));

        // TODO: eventManager 사용시 preventDefault 시의 문제가 있을것으로 추정됨 (테스트 필요) - 확인하여 가능하면 eventManager를 사용하도록 작업 필요
        this.onBindedPaste = this._onPaste.bind(this);
        this.wwe.getEditor().addEventListener('paste', this.onBindedPaste);
    }

    /**
     * On paste.
     * @param {MouseEvent} ev - event
     */
    _onPaste(ev) {
        const range = this.wwe.getEditor().getSelection();
        const isNotPastingIntoTextNode = !domUtils.isTextNode(range.commonAncestorContainer);

        if (this.isInTable(range) &amp;&amp; !range.collapsed &amp;&amp; isNotPastingIntoTextNode) {
            ev.preventDefault();
        }
        this.wwe.defer(() => {
            this._completeTableIfNeed();
        }, TABLE_COMPLETION_DELAY);
    }

    /**
     * _initKeyHandler
     * Initialize key event handler
     * @memberOf WwTableManager
     * @private
     */
    _initKeyHandler() {
        this.keyEventHandlers = {
            'DEFAULT': (ev, range, keymap) => {
                const isRangeInTable = this.isInTable(range);

                if (isRangeInTable &amp;&amp; !this._isSingleModifierKey(keymap)) {
                    this._recordUndoStateIfNeed(range);
                    this._removeBRIfNeed(range);
                    this._removeContentsAndChangeSelectionIfNeed(range, keymap, ev);
                } else if (!isRangeInTable &amp;&amp; this._lastCellNode) {
                    this._recordUndoStateAndResetCellNode(range);
                }

                if (isRangeInTable &amp;&amp; !this._isModifierKeyPushed(ev)) {
                    this.wwe.getEditor().modifyDocument(() => {
                        const selectionManager = this.wwe.componentManager.getManager('tableSelection');

                        selectionManager.removeClassAttrbuteFromAllCellsIfNeed();
                    });
                }
            },
            'ENTER': (ev, range) => {
                let isNeedNext;

                if (this._isAfterTable(range)) {
                    ev.preventDefault();
                    range.setStart(range.startContainer, range.startOffset - 1);
                    this.wwe.breakToNewDefaultBlock(range);
                    isNeedNext = false;
                } else if (this._isBeforeTable(range)) {
                    ev.preventDefault();
                    this.wwe.breakToNewDefaultBlock(range, 'before');
                    isNeedNext = false;
                } else if (this.isInTable(range)) {
                    this._appendBrIfTdOrThNotHaveAsLastChild(range);
                    isNeedNext = false;
                }

                return isNeedNext;
            },
            'BACK_SPACE': (ev, range, keymap) => this._handleBackspaceAndDeleteKeyEvent(ev, range, keymap),
            'DELETE': (ev, range, keymap) => this._handleBackspaceAndDeleteKeyEvent(ev, range, keymap),
            'TAB': () => this._moveCursorTo('next', 'cell'),
            'SHIFT+TAB': ev => this._moveCursorTo('previous', 'cell', ev),
            'UP': ev => this._moveCursorTo('previous', 'row', ev),
            'DOWN': ev => this._moveCursorTo('next', 'row', ev)
        };

        util.forEach(this.keyEventHandlers, (handler, key) => this.wwe.addKeyEventHandler(key, handler));

        this._bindKeyEventForTableCopyAndCut();
    }

    /**
     * isInTable
     * Check whether passed range is in table or not
     * @param {Range} range range
     * @returns {boolean} result
     * @memberOf WwTableManager
     * @api
     */
    isInTable(range) {
        let target, result;

        if (range.collapsed) {
            target = range.startContainer;
            result = !!$(target).closest('table').length;
        } else {
            target = range.commonAncestorContainer;
            result = !!$(target).closest('table').length || !!$(range.cloneContents()).find('table').length;
        }

        return result;
    }

    /**
     * _isBeforeTable
     * Check whether passed range is right before table or not
     * @param {Range} range range
     * @returns {boolean} result
     * @memberOf WwTableManager
     * @private
     */
    _isBeforeTable(range) {
        return domUtils.getNodeName(domUtils.getChildNodeByOffset(range.startContainer, range.startOffset)) === 'TABLE';
    }

    /**
     * _isAfterTable
     * Check whether passed range is right after table or not
     * @param {Range} range range
     * @returns {boolean} result
     * @memberOf WwTableManager
     * @private
     */
    _isAfterTable(range) {
        const prevElem = domUtils.getPrevOffsetNodeUntil(range.startContainer, range.startOffset);

        return domUtils.getNodeName(prevElem) === 'TABLE' &amp;&amp; range.commonAncestorContainer === this.wwe.get$Body()[0];
    }

    /**
     * Handle backspace and delete key event
     * @param {object} ev Event object
     * @param {Range} range Range Object
     * @param {string} keymap keymap
     * @returns {boolean|null}
     * @private
     */
    _handleBackspaceAndDeleteKeyEvent(ev, range, keymap) {
        const isBackspace = keymap === 'BACK_SPACE';
        const isTextOrElementDelete = range.commonAncestorContainer.nodeType !== 3
            &amp;&amp; range.commonAncestorContainer !== this.wwe.get$Body()[0];
        let isNeedNext;

        if (range.collapsed) {
            if (this.isInTable(range)) {
                if (isBackspace) {
                    this._tableHandlerOnBackspace(range, ev);
                } else {
                    this._tableHandlerOnDelete(range, ev);
                }

                this._insertBRIfNeed(range);
                this._removeContentsAndChangeSelectionIfNeed(range, keymap, ev);
                isNeedNext = false;
            } else if ((!isBackspace &amp;&amp; this._isBeforeTable(range))
                || (isBackspace &amp;&amp; this._isAfterTable(range))
            ) {
                ev.preventDefault();
                const startOffset = (isBackspace ? range.startOffset - 1 : range.startOffset);
                this._removeTable(range, domUtils.getChildNodeByOffset(range.startContainer, startOffset));
                isNeedNext = false;
            }
        } else if (this.isInTable(range)) {
            if (isTextOrElementDelete) {
                ev.preventDefault();
                this._removeContentsAndChangeSelectionIfNeed(range, keymap, ev);
                isNeedNext = false;
            }
        }

        return isNeedNext;
    }

    /**
     * _tableHandlerOnBackspace
     * Backspace handler in table
     * @param {Range} range range
     * @param {Event} event event
     * @memberOf WwTableManager
     * @private
     */
    _tableHandlerOnBackspace(range, event) {
        const prevNode = domUtils.getPrevOffsetNodeUntil(range.startContainer, range.startOffset, 'TR'),
            prevNodeName = domUtils.getNodeName(prevNode);

        if (!prevNode || prevNodeName === 'TD' || prevNodeName === 'TH') {
            event.preventDefault();
        } else if (prevNodeName === 'BR' &amp;&amp; prevNode.parentNode.childNodes.length !== 1) {
            event.preventDefault();
            $(prevNode).remove();
        }
    }
    /**
     * Return whether delete non text or not
     * @param {Range} range Range object
     * @returns {boolean}
     */
    isNonTextDeleting(range) {
        const currentElement = range.startContainer;
        const nextNode = currentElement.nextSibling;
        const nextNodeName = domUtils.getNodeName(nextNode);
        const currentNodeName = domUtils.getNodeName(currentElement);

        const isCellDeleting = currentNodeName === nextNodeName &amp;&amp; currentNodeName !== 'TEXT';
        const isEndOfText = (!nextNode || (nextNodeName === 'BR' &amp;&amp; nextNode.parentNode.lastChild === nextNode))
            &amp;&amp; (domUtils.isTextNode(currentElement) &amp;&amp; range.startOffset === currentElement.nodeValue.length);
        const isLastCellOfRow = !isEndOfText
            &amp;&amp; $(currentElement).parents('tr').children().last()[0] === currentElement
            &amp;&amp; (currentNodeName === 'TD' || currentNodeName === 'TH');

        return isCellDeleting || isEndOfText || isLastCellOfRow;
    }
    /**
     * _tableHandlerOnDelete
     * Delete handler in table
     * @param {Range} range range
     * @param {Event} event event
     * @memberOf WwTableManager
     * @private
     */
    _tableHandlerOnDelete(range, event) {
        const needPreventDefault = this.isNonTextDeleting(range);

        if (needPreventDefault) {
            event.preventDefault();
            range.startContainer.normalize();
        }
    }

    /**
     * _appendBrIfTdOrThNotHaveAsLastChild
     * Append br if td or th doesn't have br as last child
     * @param {Range} range range
     * @memberOf WwTableManager
     * @private
     */
    _appendBrIfTdOrThNotHaveAsLastChild(range) {
        const startContainerNodeName = domUtils.getNodeName(range.startContainer);
        let tdOrTh;

        if (startContainerNodeName === 'TD' || startContainerNodeName === 'TH') {
            tdOrTh = range.startContainer;
        } else {
            const paths = $(range.startContainer).parentsUntil('tr');
            tdOrTh = paths[paths.length - 1];
        }

        if (domUtils.getNodeName(tdOrTh.lastChild) !== 'BR'
            &amp;&amp; domUtils.getNodeName(tdOrTh.lastChild) !== 'DIV'
            &amp;&amp; !isIE10And11
        ) {
            $(tdOrTh).append($('&lt;br />')[0]);
        }
    }

    /**
     * _unwrapBlockInTable
     * Unwrap default block tag in table
     * For Squire default action making abnormal behavior, remove default blocks in Table after setValue() called
     * @memberOf WwTableManager
     * @private
     */
    _unwrapBlockInTable() {
        this.wwe.get$Body().find('td div,th div,tr>br,td>br,th>br').each((index, node) => {
            if (domUtils.getNodeName(node) === 'BR') {
                const parentNodeName = domUtils.getNodeName(node.parentNode);
                const isInTableCell = /TD|TH/.test(parentNodeName);
                const isEmptyTableCell = node.parentNode.textContent.length === 0;
                const isLastBR = node.parentNode.lastChild === node;

                if (parentNodeName === 'TR' || (isInTableCell &amp;&amp; !isEmptyTableCell &amp;&amp; isLastBR)) {
                    $(node).remove();
                }
            } else {
                $(node).children().unwrap();
            }
        });
    }

    /**
     * Insert default block between table element
     * @private
     */
    _insertDefaultBlockBetweenTable() {
        this.wwe.get$Body().find('table').each((index, node) => {
            if (node.nextElementSibling
                &amp;&amp; node.nextElementSibling.nodeName === 'TABLE'
            ) {
                $('&lt;div>&lt;br />&lt;/div>').insertAfter(node);
            }
        });
    }

    /**
     * _removeTable
     * Remove table
     * @param {Range} range range
     * @param {Node} table table
     * @memberOf WwTableManager
     * @private
     */
    _removeTable(range, table) {
        if (table.tagName === 'TABLE') {
            this.wwe.getEditor().saveUndoState(range);
            this.wwe.saveSelection(range);
            $(table).remove();
            this.wwe.restoreSavedSelection();
        }
    }

    /**
     * _recordUndoStateIfNeed
     * record undo state if need
     * @param {Range} range range
     * @memberOf WwTableManager
     * @private
     */
    _recordUndoStateIfNeed(range) {
        const currentCellNode = domUtils.getParentUntil(range.startContainer, 'TR');

        if (range.collapsed &amp;&amp; currentCellNode &amp;&amp; this._lastCellNode !== currentCellNode) {
            this.wwe.getEditor().saveUndoState(range);
            this._lastCellNode = currentCellNode;
        }
    }

    /**
     * _recordUndoStateAndResetCellNode
     * record undo state and reset last cell node
     * @param {Range} range range
     * @memberOf WwTableManager
     * @private
     */
    _recordUndoStateAndResetCellNode(range) {
        this.wwe.getEditor().saveUndoState(range);
        this.resetLastCellNode();
    }

    /**
     * Paste table data into table element
     * @param {DocumentFragment} fragment Fragment of table element within
     * @private
     */
    _pasteDataIntoTable(fragment) {
        const range = this.wwe.getEditor().getSelection();
        const tableData = this._getTableDataFromTable(fragment);
        const startContainer = range.startContainer;
        const parentNode = startContainer.parentNode;
        const isTextInTableCell = (parentNode.tagName === 'TD' || parentNode.tagName === 'TH');
        const isTableCell = (startContainer.tagName === 'TD' || startContainer.tagName === 'TH');
        const isTextNode = startContainer.nodeType === 3;
        const brString = isIE10 ? '' : '&lt;br />';
        let anchorElement, td, tr, tdContent;

        if (isTextNode &amp;&amp; isTextInTableCell) {
            anchorElement = parentNode;
        } else if (isTableCell) {
            anchorElement = startContainer;
        } else {
            anchorElement = $(startContainer).find('th,td')[0];
        }

        td = anchorElement;

        while (tableData.length) {
            tr = tableData.shift();

            while (td &amp;&amp; tr.length) {
                tdContent = tr.shift();

                if (tdContent.length) {
                    td.textContent = tdContent;
                } else {
                    td.innerHTML = brString;
                }

                td = domUtils.getTableCellByDirection(td, 'next');
            }

            td = domUtils.getSiblingRowCellByDirection(anchorElement, 'next', false);
            anchorElement = td;
        }
    }

    /**
     * Get array data from table element
     * @param {DocumentFragment} fragment table element
     * @returns {Array}
     * @private
     */
    _getTableDataFromTable(fragment) {
        const $fragment = $(fragment);
        const tableData = [];
        const trs = $fragment.find('tr');

        trs.each((i, tr) => {
            const trData = [];
            const tds = $(tr).children();

            tds.each((index, cell) => {
                trData.push(cell.textContent);
            });

            if (trData.length) {
                tableData.push(trData);
            }
        });

        return tableData;
    }

    /**
     * Remove selected table contents
     * @param {jQuery} selectedCells Selected cells wrapped by jQuery
     * @private
     */
    _removeTableContents(selectedCells) {
        this.wwe.getEditor().saveUndoState();

        selectedCells.each((i, cell) => {
            const brHTMLString = isIE10 ? '' : '&lt;br />';
            $(cell).html(brHTMLString);
        });
    }

    /**
     * Wrap dangling table cells with new TR
     * @param {DocumentFragment} fragment Pasting data
     * @returns {HTMLElement|null}
     */
    wrapDanglingTableCellsIntoTrIfNeed(fragment) {
        const danglingTableCells = $(fragment).children('td,th');
        let tr;

        if (danglingTableCells.length) {
            const $wrapperTr = $('&lt;tr>&lt;/tr>');

            danglingTableCells.each((i, cell) => {
                $wrapperTr.append(cell);
            });

            tr = $wrapperTr[0];
        }

        return tr;
    }

    /**
     * Wrap TRs with new TBODY
     * @param {DocumentFragment} fragment Pasting data
     * @returns {HTMLElement|null}
     */
    wrapTrsIntoTbodyIfNeed(fragment) {
        const danglingTrs = $(fragment).children('tr');
        const ths = danglingTrs.find('th');
        let tbody;

        if (ths.length) {
            ths.each((i, node) => {
                const $node = $(node);
                const td = $('&lt;td>&lt;/td>');

                td.html($node.html());
                td.insertBefore(node);

                $node.detach();
            });
        }

        if (danglingTrs.length) {
            const $wrapperTableBody = $('&lt;tbody>&lt;/tbody>');

            danglingTrs.each((i, tr) => {
                $wrapperTableBody.append(tr);
            });

            tbody = $wrapperTableBody[0];
        }

        return tbody;
    }

    /**
     * Wrap THEAD followed by TBODY both into Table
     * @param {DocumentFragment} fragment Pasting data
     * @returns {HTMLElement|null}
     */
    wrapTheadAndTbodyIntoTableIfNeed(fragment) {
        const danglingThead = $(fragment).children('thead');
        const danglingTbody = $(fragment).children('tbody');
        const $wrapperTable = $('&lt;table>&lt;/table>');
        let table;

        if (!danglingTbody.length &amp;&amp; danglingThead.length) {
            $wrapperTable.append(danglingThead[0]);
            $wrapperTable.append('&lt;tbody>&lt;tr>&lt;/tr>&lt;/tbody>');
            table = $wrapperTable[0];
        } else if (danglingTbody.length &amp;&amp; !danglingThead.length) {
            $wrapperTable.append('&lt;thead>&lt;tr>&lt;/tr>&lt;/thead>');
            $wrapperTable.append(danglingTbody[0]);
            table = $wrapperTable[0];
        } else if (danglingTbody.length &amp;&amp; danglingThead.length) {
            $wrapperTable.append(danglingThead[0]);
            $wrapperTable.append(danglingTbody[0]);
            table = $wrapperTable[0];
        }

        return table;
    }
    /**
     * Prepare to paste data on table
     * @param {object} pasteData Pasting data
     * @param {HTMLElement} node Current pasting element
     * @returns {DocumentFragment}
     * @memberOf WwTableManager
     * @api
     */
    prepareToPasteOnTable(pasteData, node) {
        const newFragment = document.createDocumentFragment();
        if (this._isTableOrSubTableElement(node.nodeName)) {
            this._expandTableIfNeed(pasteData.fragment);
            this._pasteDataIntoTable(pasteData.fragment);
            pasteData.fragment = newFragment;
        } else {
            newFragment.textContent = newFragment.textContent + pasteData.fragment.textContent;
        }

        return newFragment;
    }

    /**
     * Whether pasting element is table element
     * @param {string} pastingNodeName Pasting node name
     * @returns {boolean}
     * @private
     */
    _isTableOrSubTableElement(pastingNodeName) {
        return (pastingNodeName === 'TABLE' || pastingNodeName === 'TBODY'
            || pastingNodeName === 'THEAD' || pastingNodeName === 'TR' || pastingNodeName === 'TD');
    }

    /**
     * Stuff table cells into incomplete rows
     * @param {jQuery} $trs jQuery wrapped TRs
     * @param {number} maximumCellLength maximum cell length of table
     * @private
     */
    _stuffTableCellsIntoIncompleteRow($trs, maximumCellLength) {
        $trs.each((rowIndex, row) => {
            const $row = $(row);
            const tableCells = $row.find('th,td');
            const parentNodeName = domUtils.getNodeName($row.parent()[0]);
            const cellTagName = parentNodeName === 'THEAD' ? 'th' : 'td';

            for (let cellLength = tableCells.length; cellLength &lt; maximumCellLength; cellLength += 1) {
                $row.append($(tableCellGenerator(1, cellTagName))[0]);
            }
        });
    }

    /**
     * Prepare to table cell stuffing
     * @param {jQuery} $trs jQuery wrapped TRs
     * @returns {{maximumCellLength: *, needTableCellStuffingAid: boolean}}
     */
    prepareToTableCellStuffing($trs) {
        let maximumCellLength = $trs.eq(0).find('th,td').length;
        let needTableCellStuffingAid = false;

        $trs.each((i, row) => {
            const cellCount = $(row).find('th,td').length;

            if (maximumCellLength !== cellCount) {
                needTableCellStuffingAid = true;

                if (maximumCellLength &lt; cellCount) {
                    maximumCellLength = cellCount;
                }
            }
        });

        return {
            maximumCellLength,
            needTableCellStuffingAid
        };
    }

    /**
     * Add TBODY or THEAD if need
     * @param {jQuery} table Table element
     * @private
     */
    _addTbodyOrTheadIfNeed(table) {
        const isTheadNotExists = !table.find('thead').length;
        const isTbodyNotExists = !table.find('tbody').length;
        let absentNode;

        if (isTheadNotExists) {
            absentNode = $('&lt;thead>&lt;tr>&lt;/tr>&lt;/thead>')[0];
            table.prepend(absentNode);
        } else if (isTbodyNotExists) {
            absentNode = $('&lt;tbody>&lt;tr>&lt;/tr>&lt;/tbody>')[0];
            table.append(absentNode);
        }
    }

    /**
     * Append table cells
     * @param {HTMLElement} node Table element
     */
    tableCellAppendAidForTableElement(node) {
        const table = $(node);

        this._addTbodyOrTheadIfNeed(table);
        this._addTrIntoContainerIfNeed(table);

        const trs = table.find('tr');
        const tableAidInformation = this.prepareToTableCellStuffing(trs);
        const maximumCellLength = tableAidInformation.maximumCellLength;
        const needTableCellStuffingAid = tableAidInformation.needTableCellStuffingAid;

        if (needTableCellStuffingAid) {
            this._stuffTableCellsIntoIncompleteRow(trs, maximumCellLength);
        }
    }

    /**
     * Generate THEAD and append TDs with same amount of given TBODY
     * @param {HTMLElement} node TR element
     * @returns {{thead: HTMLElement, tbody: HTMLElement}}
     * @private
     */
    _generateTheadAndTbodyFromTbody(node) {
        const tr = $('&lt;tr>&lt;/tr>');
        const thead = $('&lt;thead>&lt;/thead>');

        tr.append(tableCellGenerator($(node).find('tr').eq(0).find('td').length, 'th'));
        thead.append(tr);

        return {
            thead: thead[0],
            tbody: node
        };
    }

    /**
     * Generate TBODY and append TDs with same amount of given THEAD
     * @param {HTMLElement} node TR element
     * @returns {{thead: HTMLElement, tbody: HTMLElement}}
     * @private
     */
    _generateTheadAndTbodyFromThead(node) {
        const tr = $('&lt;tr>&lt;/tr>');
        const tbody = $('&lt;tbody>&lt;/tbody>');

        tr.append(tableCellGenerator($(node).find('th').length, 'td'));
        tbody.append(tr);

        return {
            thead: node,
            tbody: tbody[0]
        };
    }

    /**
     * Generate THEAD and TBODY and append given TR within
     * @param {HTMLElement} node TR element
     * @returns {{thead: HTMLElement, tbody: HTMLElement}}
     * @private
     */
    _generateTheadAndTbodyFromTr(node) {
        const $node = $(node);
        const thead = $('&lt;thead>&lt;/thead>');
        const tbody = $('&lt;tbody>&lt;/tbody>');
        let theadRow, tbodyRow;

        if ($node.children()[0].tagName === 'TH') {
            theadRow = node;
            tbodyRow = $(`&lt;tr>${tableCellGenerator($node.find('th').length, 'td')}&lt;/tr>`)[0];
        } else {
            theadRow = $(`&lt;tr>${tableCellGenerator($node.find('td').length, 'th')}&lt;/tr>`)[0];
            tbodyRow = node;
        }

        thead.append(theadRow);
        tbody.append(tbodyRow);

        return {
            thead: thead[0],
            tbody: tbody[0]
        };
    }

    /**
     * Complete passed table
     * @param {HTMLElement} node Table inner element
     * @private
     */
    _completeIncompleteTable(node) {
        const nodeName = node.tagName;
        let table, completedTableContents;

        if (nodeName === 'TABLE') {
            table = node;
        } else {
            table = $('&lt;table>&lt;/table>');
            table.insertAfter(node);

            if (nodeName === 'TBODY') {
                completedTableContents = this._generateTheadAndTbodyFromTbody(node);
            } else if (nodeName === 'THEAD') {
                completedTableContents = this._generateTheadAndTbodyFromThead(node);
            } else if (nodeName === 'TR') {
                completedTableContents = this._generateTheadAndTbodyFromTr(node);
            }
            table.append(completedTableContents.thead);
            table.append(completedTableContents.tbody);
        }

        this.tableCellAppendAidForTableElement(table);
    }

    /**
     * Whole editor body searching incomplete table completion
     * @private
     */
    _completeTableIfNeed() {
        const $body = this.wwe.getEditor().get$Body();

        $body.children().each((index, node) => {
            const $node = $(node);

            if (!this._isTableOrSubTableElement(node.nodeName)) {
                return;
            } else if (node.nodeName === 'TABLE'
                &amp;&amp; $node.find('thead').length === 0
                &amp;&amp; $node.find('tbody').length === 0
            ) {
                $node.remove();
            }

            this._completeIncompleteTable(node);
        });
    }

    /**
     * Reset _lastCellNode to null
     * @memberOf WwTableManager
     */
    resetLastCellNode() {
        this._lastCellNode = null;
    }
    /**
     * Set _lastCellNode to given node
     * @param {HTMLElement} node Table cell
     * @memberOf WwTableManager
     */
    setLastCellNode(node) {
        this._lastCellNode = node;
    }

    /**
     * Return whether only modifier key pressed or not
     * @param {string} keymap Pressed keymap string
     * @returns {boolean}
     * @private
     */
    _isSingleModifierKey(keymap) {
        return ((keymap === 'META') || (keymap === 'SHIFT') || (keymap === 'ALT') || (keymap === 'CONTROL'));
    }

    /**
     * Return whether modifier keys pressed or not
     * @param {object} ev keyboard event object
     * @returns {boolean}
     * @private
     */
    _isModifierKeyPushed(ev) {
        return (ev.metaKey || ev.ctrlKey || ev.altKey || ev.shiftKey);
    }

    /**
     * Add one row into empty TBODY
     * @param {jQuery} $table Currently processing table
     * @private
     */
    _addTrIntoContainerIfNeed($table) {
        const $trContainers = $table.children();

        $trContainers.each((i, container) => {
            const hasNoRows = $(container).find('tr').length === 0;

            if (hasNoRows) {
                $(container).append($('&lt;tr>&lt;/tr>')[0]);
            }
        });
    }

    _expandTableIfNeed(fragment) {
        const range = this.wwe.getEditor().getSelection().cloneRange();
        const $table = $(range.startContainer).parents('table');
        const difference = this._getColumnAndRowDifference(fragment, range);

        if (difference.column &lt; 0) {
            this._appendCellForAllRow($table, difference.column);
        }

        if (difference.row &lt; 0) {
            this._appendRow($table, difference.row);
        }
    }

    _getColumnAndRowDifference(fragment, range) {
        const tableData = this._getTableDataFromTable(fragment);
        const rowLength = tableData.length;
        const columnLength = tableData[0].length;
        const $currentCell = $(range.startContainer).closest('th,td');
        const $currentRow = $currentCell.parent();
        const currentColumnIndex = domUtils.getNodeOffsetOfParent($currentCell[0]);
        let currentRowIndex = domUtils.getNodeOffsetOfParent($currentCell[0].parentNode);
        const $table = $currentRow.parents('table');
        const tableColumnLength = $table.find('tr').eq(0).children().length;
        const tableRowLength = $table.find('tr').length;
        const isInTbody = $currentRow.parents('tbody').length;

        if (isInTbody) {
            currentRowIndex += 1;
        }

        return {
            row: tableRowLength - (currentRowIndex + rowLength),
            column: tableColumnLength - (currentColumnIndex + columnLength)
        };
    }

    _appendCellForAllRow($table, columnDifference) {
        const brString = isIE10 ? '' : '&lt;br />';

        $table.find('tr').each((i, row) => {
            let tagName;

            for (let index = columnDifference; index &lt; 0; index += 1) {
                if (i === 0) {
                    tagName = 'th';
                } else {
                    tagName = 'td';
                }
                $(row).append($(`&lt;${tagName}>${brString}&lt;/${tagName}>`)[0]);
            }
        });
    }

    _appendRow($table, rowDifference) {
        const newRow = $table.find('tr').last().clone();
        const brHTMLSting = isIE10 ? '' : '&lt;br />';

        newRow.find('td').html(brHTMLSting);

        for (; rowDifference &lt; 0; rowDifference += 1) {
            $table.find('tbody').append(newRow.clone()[0]);
        }
    }

    /**
     * Get sibling textNode by given direction
     * @param {HTMLElement} currentTextNode Current text node
     * @param {boolean} isNext Boolean value whether direction equals 'next'
     * @returns {boolean|null}
     * @private
     */
    _getSiblingTextNodeByDirection(currentTextNode, isNext) {
        const isPreviousLineExist = currentTextNode.previousSibling
            &amp;&amp; currentTextNode.previousSibling.nodeName === 'BR'
            &amp;&amp; currentTextNode.previousSibling.previousSibling
            &amp;&amp; currentTextNode.previousSibling.previousSibling.nodeType === 3;
        const isNextLineExist = currentTextNode.nextSibling
            &amp;&amp; currentTextNode.nextSibling.nodeName === 'BR'
            &amp;&amp; currentTextNode.nextSibling.nextSibling
            &amp;&amp; currentTextNode.nextSibling.nextSibling.nodeType === 3;
        let target;

        if (isNext &amp;&amp; isNextLineExist) {
            target = currentTextNode.nextSibling.nextSibling;
        } else if (!isNext &amp;&amp; isPreviousLineExist) {
            target = currentTextNode.previousSibling.previousSibling;
        }

        return target;
    }

    /**
     * Change selection to sibling cell
     * @param {HTMLElement} currentCell current TD or TH
     * @param {Range} range Range object
     * @param {string} direction 'next' or 'previous'
     * @param {string} scale 'row' or 'cell'
     */
    _changeSelectionToTargetCell(currentCell, range, direction, scale) {
        const startContainer = range.startContainer;
        const isNext = direction === 'next';
        const isRow = scale === 'row';
        let target, textOffset;

        if (isRow) {
            if (domUtils.isTextNode(startContainer)) {
                target = this._getSiblingTextNodeByDirection(startContainer, isNext);
                if (target) {
                    textOffset = target.length &lt; range.startOffset ? target.length : range.startOffset;

                    range.setStart(target, textOffset);
                    range.collapse(true);

                    return;
                }
            }

            target = domUtils.getSiblingRowCellByDirection(currentCell, direction, false);
        } else {
            target = domUtils.getTableCellByDirection(currentCell, direction);
            if (!target) {
                target = domUtils.getSiblingRowCellByDirection(currentCell, direction, true);
            }
        }

        if (target) {
            range.setStart(target, 0);
            range.collapse(true);
        } else {
            target = $(currentCell).parents('table')[0];
            if (isNext) {
                range.setStart(target.nextElementSibling, 0);
            } else if (target.previousElementSibling &amp;&amp; target.previousElementSibling.nodeName !== 'TABLE') {
                range.setStart(target.previousElementSibling, 1);
            } else {
                range.setStartBefore(target);
            }

            range.collapse(true);
        }
    }

    /**
     * Create selection by selected cells and collapse that selection to end
     * @private
     */
    _collapseRangeToEndContainer() {
        const sq = this.wwe.getEditor();
        const range = sq.getSelection().cloneRange();
        const selectedCells = this.wwe.componentManager.getManager('tableSelection').getSelectedCells();

        if (selectedCells.length &amp;&amp; this.isInTable(range)) {
            this.wwe.defer(() => {
                range.collapse(false);
                sq.setSelection(range);
            }, SET_SELECTION_DELAY);
        }
    }

    /**
     * Move cursor to given direction by interval formatter
     * @param {string} direction 'next' or 'previous'
     * @param {string} interval 'row' or 'cell'
     * @param {object} [ev] Event object
     * @returns {boolean | null}
     * @private
     */
    _moveCursorTo(direction, interval, ev) {
        const sq = this.wwe.getEditor();
        const range = sq.getSelection().cloneRange();
        const currentCell = $(range.startContainer).closest('td,th')[0];
        let isNeedNext;

        if (range.collapsed) {
            if (this.isInTable(range) &amp;&amp; currentCell) {
                if ((direction === 'previous' || interval === 'row')
                    &amp;&amp; !util.isUndefined(ev)
                ) {
                    ev.preventDefault();
                }

                this._changeSelectionToTargetCell(currentCell, range, direction, interval);
                sq.setSelection(range);

                isNeedNext = false;
            }
        }

        return isNeedNext;
    }

    /**
     * Bind pre process for table copy and cut key event
     * @private
     */
    _bindKeyEventForTableCopyAndCut() {
        const isMac = /Mac OS X/.test(navigator.userAgent);
        const commandKey = isMac ? 'metaKey' : 'ctrlKey';

        // TODO: eventManager 사용시 preventDefault 시의 문제가 있을것으로 추정됨 (테스트 필요) - 확인하여 가능하면 eventManager를 사용하도록 작업 필요
        this.onBindedKeydown = ev => {
            const selectionManager = this.wwe.componentManager.getManager('tableSelection');

            if (ev[commandKey]) {
                selectionManager.createRangeBySelectedCells();
            }
        };
        this.onBindedKeyup = this._collapseRangeToEndContainer.bind(this);

        this.wwe.getEditor().addEventListener('keydown', this.onBindedKeydown);
        this.wwe.getEditor().addEventListener('keyup', this.onBindedKeyup);
    }

    /**
     * Remove contents and change selection if need
     * @param {Range} range Range object
     * @param {string} keymap keymap
     * @param {object} ev Event object
     * @private
     */
    _removeContentsAndChangeSelectionIfNeed(range, keymap, ev) {
        const isTextInput = keymap.length &lt;= 1;
        const isDeleteOperation = (keymap === 'BACK_SPACE' || keymap === 'DELETE');
        const selectedCells = this.wwe.componentManager.getManager('tableSelection').getSelectedCells();
        const firstSelectedCell = selectedCells.first()[0];

        if ((isTextInput || isDeleteOperation) &amp;&amp; !this._isModifierKeyPushed(ev) &amp;&amp; selectedCells.length) {
            if (isDeleteOperation) {
                this._recordUndoStateIfNeed(range);
            }
            this._removeTableContents(selectedCells);

            this._lastCellNode = firstSelectedCell;

            range.setStart(firstSelectedCell, 0);
            range.collapse(true);
            this.wwe.getEditor().setSelection(range);
        }
    }

    /**
     * Return new table ID class name string
     * @returns {string}
     * @memberOf WwTableManager
     * @api
     */
    getTableIDClassName() {
        const tableClassName = TABLE_CLASS_PREFIX + this.tableID;
        this.tableID += 1;

        return tableClassName;
    }

    /**
     * Remove br when text inputted
     * @param {Range} range Range object
     * @private
     */
    _removeBRIfNeed(range) {
        const isText = domUtils.isTextNode(range.startContainer);
        const startContainer = isText ? range.startContainer.parentNode : range.startContainer;
        const nodeName = domUtils.getNodeName(startContainer);

        if (/td|th/i.test(nodeName) &amp;&amp; range.collapsed &amp;&amp; startContainer.textContent.length === 1) {
            $(startContainer).find('br').remove();
        }
    }


    /**
     * Insert br when text deleted
     * @param {Range} range Range object
     * @private
     */
    _insertBRIfNeed(range) {
        const isText = domUtils.isTextNode(range.startContainer);
        const currentCell = isText ? range.startContainer.parentNode : range.startContainer;
        const nodeName = domUtils.getNodeName(currentCell);
        const $currentCell = $(currentCell);

        if (/td|th/i.test(nodeName)
            &amp;&amp; range.collapsed
            &amp;&amp; !currentCell.textContent.length
            &amp;&amp; !$currentCell.children().length
            &amp;&amp; !isIE10And11
        ) {
            currentCell.normalize();
            $currentCell.append('&lt;br>');
        }
    }

    /**
     * Destroy.
     */
    destroy() {
        this.eventManager.removeEventHandler('wysiwygRangeChangeAfter.table');
        this.eventManager.removeEventHandler('wysiwygSetValueAfter.table');
        this.eventManager.removeEventHandler('wysiwygProcessHTMLText.table');
        this.wwe.getEditor().removeEventListener('paste', this.onBindedPaste);
        this.wwe.getEditor().removeEventListener('keydown', this.onBindedKeydown);
        this.wwe.getEditor().removeEventListener('keyup', this.onBindedKeyup);

        util.forEach(this.keyEventHandlers, (handler, key) => this.wwe.removeKeyEventHandler(key, handler));
    }
}

/**
 * Generate table cell HTML text
 * @param {number} amount Amount of cells
 * @param {string} tagName Tag name of cell 'td' or 'th'
 * @private
 * @returns {string}
 */
function tableCellGenerator(amount, tagName) {
    const brHTMLString = '&lt;br />';
    const cellString = `&lt;${tagName}>${brHTMLString}&lt;/${tagName}>`;
    let tdString = '';

    for (let i = 0; i &lt; amount; i += 1) {
        tdString = tdString + cellString;
    }

    return tdString;
}

module.exports = WwTableManager;

</code></pre>
        </article>
    </section>




</div>

<footer>
    <img class="logo" src="img/toast-ui.png" style="">
    <div class="footer-text">NHN Entertainment. Frontend Development Lab</div>
</footer>
<script>prettyPrint();</script>
<script src="scripts/jquery.min.js"></script>
<script src="scripts/tui-doc.js"></script>
<script src="scripts/linenumber.js"></script>

    <script>
        var id = '_sub'.replace(/"/g, '_');
        var element = document.getElementById(id); // do not use jquery selector

        $(element).removeClass('hidden');
        showLnbApi();
    </script>

</body>
</html>
